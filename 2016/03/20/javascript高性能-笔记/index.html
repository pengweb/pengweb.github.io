<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title> javascript高性能---笔记 | 张鹏的全栈之路 </title>
	<meta property="og:title" content=" javascript高性能---笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:title" content=" javascript高性能---笔记 | 张鹏的全栈之路 ">

	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary">

	<meta name="description" content=" javascript高性能---笔记 | 张鹏的全栈之路 ">
	<meta property="og:description" content=" javascript高性能---笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:description" content=" javascript高性能---笔记 | 张鹏的全栈之路 " />

	<link rel="icon" type="image/x-icon" href="http://yoursite.com/asset/img/favicon.png">

	<link rel="image_src" href="http://yoursite.com/asset/img/logo.png" >
	<meta property="og:image" content="http://yoursite.com/asset/img/logo.png" />

	<link href="http://yoursite.com/atom.xml" title="张鹏的全栈之路" type="application/atom+xml" rel="alternative">

	<link rel="canonical" href="/2016/03/20/javascript高性能-笔记/index.html">

	<link rel="stylesheet" href="/asset/css/style.css">

</head>

<body>

	<div class="layout-header">
		<header class="header">
			<div class="layout-logo">
				<div class="panel-logo">

					<div class="box-logo box-log-md">
						<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
					</div>
					<div class="box-main-title">
						<h5 style="text-align: center">
							<span>Love life,love ourselves！--Pengzhang</span>
						</h5>
					</div>
					<div class="box-sub-title">

					</div>
				</div>
			</div>
			<div class="layout-menu">
				<div class="box-logo box-log-xs">
					<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
				</div>
				<div class="box-menu-list">
					<nav class="page-nav">
						<ul class="menu-list">

							<li class="box-menu-item"><a href="/"><span class="menu-item">HOME</span></a></li>

							<li class="box-menu-item"><a href="/tags/nodejs"><span class="menu-item">Node.js</span></a></li>

							<li class="box-menu-item"><a href="/tags/html"><span class="menu-item">Html</span></a></li>

							<li class="box-menu-item"><a href="/tags/css"><span class="menu-item">Css</span></a></li>

							<li class="box-menu-item"><a href="/tags/note"><span class="menu-item">Note</span></a></li>

							<li class="box-menu-item"><a href="/tags/others"><span class="menu-item">Others</span></a></li>

							<li class="box-menu-item"><a href="/archives"><span class="menu-item">Sitemap</span></a></li>

						</ul>
					</nav>

				</div>
			</div>
		</header>
	</div>

	<div class="layout-content">


		<div class="row panel-content panel-post-item">
			<div class="box-post-item">
				<article class="post-item" itemscope itemtype="http://schema.org/Article">




					<p class="content-meta">
						<span class="meta-date" itemprop="datePublished" content="2016-03-20">2016-03-20</span>


					</p>


					<h2 class="box-content-title">
						<a href="/2016/03/20/javascript高性能-笔记/"  itemprop="url"><span class="content-title" itemprop="name">javascript高性能---笔记</span></a>
					</h2>

					<div class="content post-item-content" itemprop="articleBody">

<p><code>递归的两个算法和回溯理解不好，BigPipe</code></p>
<h1 id="1-加载和执行"><a href="#1-加载和执行" class="headerlink" title="1.加载和执行"></a>1.加载和执行</h1><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>1.每次遇到<code>script</code>标签，都会霸道的让页面等待脚本解析和执行。<br>2.浏览器在解析到<code>body</code>标签之前，是不会渲染页面的任何部分的。<br>3.file1.js和file2.js之间<strong>存在一个延时</strong>，这段时间是file1.js执行的过程，所以下载和执行是逐个的。<br>4.开始加载图片，只在乎有没有图片，不在乎清不清晰，可以先加载模糊小图<br>5.更多加载参考文献：<a href="https://github.com/ChenChenJoke/JokerWebFont/tree/master/Performance" target="_blank" rel="external">https://github.com/ChenChenJoke/JokerWebFont/tree/master/Performance</a></p>
<h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>1.将script标签放到body底部<br>2.减少script标签数量。（每个script标签初始下载时都会阻塞页面渲染，并且下载js后会有延时，减少数量最小化延时）<br>3.不要直接放在link标签后，防止阻塞页面去等待样式表下载<br>4.减少外链数，下载1个100kb文件比4个25kb文件快<br>5.无阻塞脚本。<br>方法一：defer/async属性<br>实际应用中，执行顺序不定，所以不推荐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&apos;file.js&apos; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>方法二：动态插入<br>元素被添加到页面时开始下载，无论何时启动下载和执行，都<strong>不会阻塞</strong>页面其他进程，所以放到head内更为保险。<br>如果文件内只含有供其他脚本调用接口时，会有问题，因为它无法判断是否自执行，所以就无法判断是否下载完成和准备就绪，所以通过判断readyState状态来进行插入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function loadScript(url,callback)&#123;</span><br><span class="line">	var script = document.creatElement(&apos;script&apos;);</span><br><span class="line">	if (script.readyState)&#123;</span><br><span class="line">		script.onreadystatechange = function()&#123;</span><br><span class="line">			if(script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123;</span><br><span class="line">				script.onreadystatechange = null;  //重置事件，避免处理两次</span><br><span class="line">				callback();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		script.onload = function()&#123;</span><br><span class="line">			callback();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	script.src = url;</span><br><span class="line">	document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">//注：如果想顺序执行，进行嵌套就可以了</span><br></pre></td></tr></table></figure></p>
<p>方法三：XMLHttpRequest 脚本注入<br>大型的WEB应用不会采用这种方法<br>无法从CND下载，跨域问题<br>方法四（推荐）：<br>用方法二的loadScript(),把他放到body的底部。<br>好处：1.不会阻塞页面。2.DOM结构已经创建完毕，做好交互准备。</p>
<h1 id="2-数据存取"><a href="#2-数据存取" class="headerlink" title="2.数据存取"></a>2.数据存取</h1><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>1.字面量和局部变量存取数据最快，访问数组元素和对象成员代价更高。<br>2.<strong>[[scope]]</strong>包含了一个函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链。<br>3.函数作用域中，每个对象被称为一个可变对象，每个可变对象都是以‘键值对’的形式存在。<br>4.函数每次执行时对应的<strong>执行环境</strong>都是独一无二的，所以多次调用同一个函数，会导致创建多个执行环境，造成性能问题，执行完毕后，执行环境会被销毁。<br>5.执行中，每遇到一个变量，都会经历一次解析<strong>查找同名标识符</strong>过程，搜索过程从作用域链头部开始，也就是活动对象开始，向作用域链下一个对象搜索，直到最外层的全局变量。正式这个搜索过程影响了性能。标识符所在位置越深，读写速度越慢。<strong>局部变量总是最快的，全局变量是最慢的</strong>，全局变量在最末端。<br>6.如果名字相同的两个变量存在作用域中，最先找到的那个会<strong>遮蔽</strong>后边那个。<br>7.闭包频繁访问<strong>跨作用域</strong>的标识符时，每次访问都会带来性能损耗。<br>8.对象的一个成员引用了一个函数的时候，称为”方法”，如果是非函数，则成为”属性”。<br>9.使用in操作符，可以搜索实例也可以搜索原型。只搜索实例可通过hasOwnProperty()来判断。<br>10.对象在原型链中的位置<strong>越深</strong>，找到它也就越慢。<br><em>注意：改变作用域链很危险，不推荐使用！可以改变作用域链的语法有with语句eval语句和try···catch语句(异常对象推入catch内，且在作用域首位)</em></p>
<h3 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h3><p>1.将全局变量的引用存储在一个局部变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var doc = document</span><br></pre></td></tr></table></figure></p>
<p>2.将对象的属性或者方法存储在一个局部变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var current = element.className;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-DOM编程"><a href="#3-DOM编程" class="headerlink" title="3.DOM编程"></a>3.DOM编程</h1><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>1.DOM和javascript想象为一个岛屿，之间用收费桥梁连接，每次经过都要交费，次数越多，费用越多，所以尽可能减少过桥的次数。<br>2.通过getElementsByTagName()获得的是一个类数组的集合，读取一个集合的length比读取数组的length要慢的多。（高性能P43）<br>3.浏览器下载页面后解析。<strong>DOM数→渲染树（DOM节点如何显示）→绘制。进行DOM操作后：DOM树→重新构造渲染树（重排）→重绘</strong>。改变背景色不会改变宽高，所以不用重排，只用重绘。<strong>获取布局信息</strong>导致列队刷新重新渲染（重排）。<br>4.浏览器通道有7条9条的，老ie只有2条 document.write会阻塞通道</p>
<h3 id="优化：-2"><a href="#优化：-2" class="headerlink" title="优化："></a>优化：</h3><p>1.避免在讯中中访问或者修改DOM元素，应该用局部变量存储修改中的内容，循环结束后一次写入(innerHTML),把运算尽量留在ES这一端。<br>2.使用数组来合并大量字符串，这样让innerHTML效率更高。<br>3.将DOM集合放入一个数组内，求length要比直接对集合求length快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//只是展示方法，并不推荐使用，因为在声明len这个变量的时候就已经是优化4的方法了</span><br><span class="line">function toArray(coll)&#123;</span><br><span class="line">	 a = [];</span><br><span class="line">	 len = coll.length;            //其实这一步就已经进行了缓存，完全没有必要向下进行了</span><br><span class="line">	for(var i = 0; i&lt;len; i++)&#123;</span><br><span class="line">		a[i] = coll[i];  //拷贝</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line">var coll = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">var ar = toArray(coll);</span><br><span class="line">function loopCopiedArray()&#123;</span><br><span class="line">	for (var count = 0; count&lt;arr.length; count++)&#123;</span><br><span class="line">		//代码处理</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.当遍历一个集合时，第一优化原则是把<strong>集合存储在局部变量中</strong>，并把<strong>length缓存在循环外部</strong>，然后使用<strong>局部变量替代这些需要多次读取的元素</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function collectionLocal()&#123;</span><br><span class="line">	var coll = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">	len = coll.length,</span><br><span class="line">	name = &apos;&apos;;</span><br><span class="line">	for(var count = 0; count&lt;len; count++)&#123;</span><br><span class="line">		name = coll[count].nodeName;      //避免在for内操作DOM集合</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.childNodes是个集合，所以循环中注意缓存length属性，IE中nextSibling比childNodes要快很多。<br>6.最新querySelectorAll要比使用js和DOM遍历快很多，且得到一个Nodelist集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var element = document.querySelectorAll(&apos;#menu a&apos;);   //获取id为menu下的所有a标签</span><br></pre></td></tr></table></figure></p>
<p>7.尽量少使用offsetTop、scrollTop、clientTop等获取布局信息属性，他们会刷新渲染列队，进行重排操作。<br>8.可以直接修改cssText避免一个样式修改多个style。<br>9.离线操作DOM，减少重绘和重排次数方法步骤：1.使元素脱离文档流 2.对其应用多重改变 3.把元素带回文档流</p>
<p>方法一：display<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">ul.style.display = &apos;none&apos;;</span><br><span class="line">appendDataToElement(ul,data);     //上边定义的一个操作函数的方法</span><br><span class="line">ul.style.display = &apos;block&apos;;</span><br></pre></td></tr></table></figure></p>
<p>方法二：虚拟DOM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment,data);       //对fragement进行操作；</span><br><span class="line">document.getElementById(&apos;mylist&apos;).appendChild(fragment);</span><br></pre></td></tr></table></figure></p>
<p>方法三：克隆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var old = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">var clone = old.cloneNode(true);</span><br><span class="line">appendDataToElement(clone,data);</span><br><span class="line">old.parentNode.replaceChild(clone,old);</span><br></pre></td></tr></table></figure></p>
<p>10.队列化修改<br>将需要进行重排的操作放在一起进行执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bodystyle.color = &apos;red&apos;;         //不需要重排</span><br><span class="line">bodystyle.color = &apos;whith&apos;;       //不需要重排</span><br><span class="line">tmp = computed.backgroundImage;  //需要重排</span><br><span class="line">tmp = computed.backgroundColor;  //需要重排</span><br></pre></td></tr></table></figure></p>
<p>11.赋值给变量-减少获取布局信息的次数，进行缓存布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var current = myElement.offsetLeft;</span><br></pre></td></tr></table></figure></p>
<p>12.脱离文档流，避免页面大面积重排<br><strong>绝对定位</strong>或者浮动等脱离文档流属性<br>13.大量元素使用：hover，会降低响应速度<br>14.事件委托（高级程序设计P402）<br>每绑定一个事件处理器都是有代价的，事件绑定通常发生在onload或DOMContentReady时，此时对于富交互应用来说都是一个拥堵时刻，浏览器需要跟踪每个事件处理器，即占用了更多的内存又占用了更多处理时间，所以通过事件委托只绑定到一个事件处理器上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//阻止浏览器默认事件和取消冒泡</span><br><span class="line">if(typeof e.preventDefault === &apos;function&apos;)&#123;</span><br><span class="line">	e.preventDefault();</span><br><span class="line">	e.stopPropagation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-算法和流程控制"><a href="#4-算法和流程控制" class="headerlink" title="4.算法和流程控制"></a>4.算法和流程控制</h1><h3 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h3><p>1.死循环或者长时间运行的循环严重影响用户体验。<br>2.for循环初始化中的var语句创建的是一个函数级的变量，而不是循环级。<br>3.for···in循环，可以枚举任何对象的属性名，包括实例属性和原型链上的属性，且不分顺序。且他的循环速度是最慢的，因为每次迭代都要搜索实例和原型。<br>4.关注两点：每次迭代的事务复杂度，迭代的次数。<br>5.迭代潜在问题：终止<strong>条件不明确</strong>导致函数长时间运行，使得用户进入假死状态。而且还会遇到<strong>调用栈大小限制</strong>。<br>6.潜在调用栈溢出问题的脚本不应该被发布上线。<br>7.递归两种模式：<br>模式一：函数调用自身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function recurse()&#123;</span><br><span class="line">	recurse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模式二：隐伏模式（互相调用）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function first()&#123;</span><br><span class="line">	second();</span><br><span class="line">&#125;</span><br><span class="line">function second()&#123;</span><br><span class="line">	first();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="优化：-3"><a href="#优化：-3" class="headerlink" title="优化："></a>优化：</h3><p>减少迭代工作量：<br>1.局部变量，减少对象成员及数组项的查找次数。节省25%，IE节省50%；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len = items.length</span><br></pre></td></tr></table></figure></p>
<p>2.颠倒数组的顺序，提高循环性能。<br>原理：减少一次判断，运行速度提高50%；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = items.length; i--)&#123;    //当i=0的时候，就为false了，就停止运行</span><br><span class="line">	process(items[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>减少迭代次数<br>3.达夫设备（迭代数超过1000时候，效率才会明显提升）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var i = items.length % 8;     		//循环余数次</span><br><span class="line">while(i)&#123;</span><br><span class="line">	process(items[i--]);</span><br><span class="line">&#125; </span><br><span class="line">i = Math.floor(itmes.length / 8);   //迭代倍数</span><br><span class="line">while(i)&#123;          </span><br><span class="line">	process(items[i--]);       		//8个循环同时进行</span><br><span class="line">	process(items[i--]);</span><br><span class="line">	process(items[i--]);</span><br><span class="line">	process(items[i--]);</span><br><span class="line">	process(items[i--]);</span><br><span class="line">	process(items[i--]);</span><br><span class="line">	process(items[i--]);</span><br><span class="line">	process(items[i--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.基于函数的迭代要比基本的for循环慢8倍。<br>函数迭代一般有：原生forEach(),jquery的each()等<br>5.if···else 最多判断4次，否则选择switch判断。<br>6.if最可能出现的情况放在首位判断。<br>7.if···else判断次数超过4次的时候，可以通过<strong>嵌套</strong>来<strong>缩小范围</strong>。<br>8.查找表：将集合存入数组，进行查表，适用于离散值太多的时候。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//完全抛弃循环语句</span><br><span class="line">var results = [result0,result1,result2,result3,result4];   </span><br><span class="line">return results[value]     //返回对应元素的值</span><br></pre></td></tr></table></figure></p>
<p><strong>9.避免递归，改用迭代</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//合并排序</span><br><span class="line">function mergeSort(items)&#123;</span><br><span class="line">	if(items.length == 1)&#123;</span><br><span class="line">		return items;</span><br><span class="line">	&#125;</span><br><span class="line">	var work = [];</span><br><span class="line">	for(var i=0, len=items.length; i&lt;len; i++)&#123;</span><br><span class="line">		work.push([items[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	work.push([]);  //如果数组长度为奇数</span><br><span class="line">	for(var lim=len; lim&gt;1; lim=(lim+1)/2)&#123;</span><br><span class="line">		for(var j=0,k=0; k&lt;lim; j++, k+=2)&#123;</span><br><span class="line">			work[j]=merge(work[k], work[k+1]);</span><br><span class="line">		&#125;</span><br><span class="line">		work[j] = [];  //如果数组长度为奇数</span><br><span class="line">	&#125;</span><br><span class="line">	return work[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>10.Memoization</strong><br>缓存，避免重复的计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function memoize(fundamental,cache)&#123;</span><br><span class="line">	cache = cache || &#123;&#125;;</span><br><span class="line">	var shell = function(arg)&#123;</span><br><span class="line">		if(!cache.hasOwnProperty(arg))&#123;</span><br><span class="line">			cache[arg] = fundamental(arg);</span><br><span class="line">		&#125;</span><br><span class="line">		return cache[arg];</span><br><span class="line">	&#125;</span><br><span class="line">	return shell;</span><br><span class="line">&#125;</span><br><span class="line">//缓存阶乘函数</span><br><span class="line">var memfactorial = memoize(factorial,&#123;&apos;0&apos;:1,&apos;1&apos;:1&#125;);   </span><br><span class="line">//调用新函数</span><br><span class="line">var fact6 = memfactorial(6);</span><br></pre></td></tr></table></figure></p>
<h1 id="5-字符串和正则表达式"><a href="#5-字符串和正则表达式" class="headerlink" title="5.字符串和正则表达式"></a>5.字符串和正则表达式</h1><h3 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h3><p>1.构建字符串的常用方法是：通过一个循环不断向字符串末尾添加内容，所以字符串构建是非常糟糕的。<br>2.IE8的连接原理是：创建一个新的空间，然后分别放进去，代替旧的字符串引用。<br>3.通过Array.prototype.join进行合并字符串比其他方法都慢！<br>4.赋值表达式中所有要连接的字符串都属于编译器常量，运行期花在连接过程的时间和内存可以减少到零，这种做法非常不错。<br>5.使用concat比普通的+和+=稍慢。<br>6.两个正则表达式匹配相同的文本并不意味着执行速度一样。<br>7.部分匹配比完全不匹配所用的时间要长。<br>8.正则工作原理：<strong>编译→设置起始位置→匹配每个正则表达式字元→匹配成功或失败。</strong><br>9.正则尝试2变后都失败才确认失败。<br>10.回溯：像是在走岔路口，当遇到岔路的时候就先在每个路口做一个标记。如果走了死路，就可以照原路返回，直到遇见之前所做过的标记，标记着还未尝试过的道路。如果那条路也走不能，可以继续返回，找到下一个标记，如此重复，直到找到出路，或者直到完成所有没有尝试过的路。<br>11.回溯会产生昂贵的计算消耗（低效之源）<br>12.正则表达式慢的原因通常是匹配失败的过程慢，而不是匹配成功的过程慢。</p>
<h3 id="优化：-4"><a href="#优化：-4" class="headerlink" title="优化："></a>优化：</h3><p>1.合并字符串方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str =+ &quot;one&quot; + &quot;two&quot;;          //对str进行扩充，性能最好，但是IE不太适合</span><br><span class="line">str = str + &quot;one&quot; + &quot;two&quot;;    //和上句效果相同</span><br></pre></td></tr></table></figure></p>
<p>2.正则表达式赋值给一个变量。避免重复执行这一步。<br>3.回退取值<br>匹配第三个字母是x的字符串<br>解决办法:先找到x，然后再将起始位置回退两个字符。<br>4.匹配任意字符用[\s\S]而不用.<br>5.尽量避免使用贪婪或者惰性词。贪婪量词<em>替换成惰性（非贪婪）量词</em>?<br>6.定义其实标志（^或$）,字符类（[a-z]或类似\d的速记符）和单词边界（\b）<br>7.分支尽量放在最前面，还有能不用分支尽量不用分支<br>cat|bat   可以写成[cb]at<br>8.尽量使用非捕获组（?:）<br>9.暴露必须的字元<br>优化前：/(^ab|^cd)/    优化后：/^(ab|cd)/<br>10.将复杂的表达式拆分成多个简单的片段<br>11.搜索字面字符串的时候，尽量使用属性方法来获取，避免正则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//检查是否分号结尾</span><br><span class="line">endsWithSemicolon = /;$/.test(str);</span><br><span class="line">endWithSemicolon = str.charAt(str.length -1) == &quot;;&quot;;</span><br></pre></td></tr></table></figure></p>
<p>12.去除首位空白，原生js方法trim()<br>方法一：使用两个表达式，这种方法最周全推荐使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(!String.prototype.trim)&#123;</span><br><span class="line">	String.prototype.trim = function()&#123;</span><br><span class="line">		return this.replace(/^\s+/,&quot;&quot;).replace(/\s+$/,&quot;&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他方法请查阅：高性能Javascript P100<br>13.<strong>避免回溯失控：使相邻的字元互斥，避免嵌套量词对同一字符串的相同部分多次匹配，通过重复利用预查的原子组去除不必要的回溯。</strong></p>
<h1 id="6-快速响应的用户界面"><a href="#6-快速响应的用户界面" class="headerlink" title="6.快速响应的用户界面"></a>6.快速响应的用户界面</h1><p>分析;<br>1.用户执行javascript和更新用户界面的进程通常称为“浏览器UI线程”，执行顺序为队列形式，要么运行javascript要么执行UI更新。大多数浏览器在javascript运行时会停止把心任务加入UI线程的队列中，也就是说javascript任务必须尽快结束，避免对用户体验造成影响。<br>2.浏览器限制了javascript运行时间。限制分两种：调用栈大小限制和长时间运行脚本限制。<br>3.度量运行时间多长两种方法：总时间不应该超过100毫秒<br>第一种是记录自脚本开始以来知性的语句的数量。<br>第二种是记录脚本执行的总时间。<br>4.当脚本执行时，<strong>UI不随用户交互而更新</strong>。所以为了更快响应用户，就应该通过定时器的方法来新增加一条UI线程，进行异步执行。<br><img src="/images/定时器.jpg" alt=""></p>
<p>5.创建一个定时器会造成UI线程暂停，如果它从一个任务切换到下一个任务。定时器代码会重置所有相关的浏览器限制，包括长时间运行脚本定时器，<strong>调用栈也被重置为0</strong>。<br>6.定时器不可用于测量实际时间，因为不一定在设定时间后加入队列，要等之前任务完成才加入队列。<br>7.定时器处理数组副作用：总时常增加。因为每一条处理完成后，UI线程会空闲出来，并且在下一条开始处理之前会有一段延迟。为了避免锁定浏览器，用定时器也是有必要的。<br>8.Web worker不占用UI线程，每个新的Worker都在自己的线程内运行代码。<br>9.每个Web work都有自己的全局运行环境，其功能只是js的一个子集。属性见（高性能P120）<br>10.通过postMessage()方法,实现网页代码和Worker的数据传入和传出。<br>11.Web Workers适用于那些处理纯数据，或者与浏览器UI无关的长时间运行的脚本。一般为：编码/解码大字符串，复杂数学运算（包括视频和图像处理），大数组排序等等任何超过100毫秒的任务。</p>
<h3 id="优化：-5"><a href="#优化：-5" class="headerlink" title="优化："></a>优化：</h3><p>1.把循环的工作分解到一系列定时器中。考虑：<strong>处理过程是否必须同步。数据是否必须按顺序执行。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">	process(todo.shift());   //可以取到todo.shift()删除掉的值</span><br><span class="line">	//tudo是一个数组，如果还有需要处理的元素，创建另一个定时器</span><br><span class="line">	if(todo.length&gt;0)&#123;</span><br><span class="line">		setTimeout(arguments.callee,25)    //调用自身函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,25);</span><br></pre></td></tr></table></figure></p>
<p>2.分割任务：把一个任务分解成一系列的子任务。每个独立的方法放到一个数组内，通过定时器分别执行。<br>3.跟踪代码执行时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var star = +new Data();   //+的作用是转换成数字</span><br><span class="line">process();</span><br><span class="line">var stop = +new Data();</span><br><span class="line">var time = stop-star;</span><br></pre></td></tr></table></figure></p>
<p>4.定时器嵌套实现有序定时器。定时器序列，同一时间只有一个定时器存在，只有当这个定时器结束时才会新创建一个。这样<strong>有序执行</strong>，就不会造成同一时间多个定时器存在，造成性能问题了。由最外层向最内层执行。<br>5.创建一个独立的重复定时器，每次执行多个任务。<br>6.Web Workers用法（高级程序设计P699）<br>WebWorkerExample01.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        (function()&#123;</span><br><span class="line">            var data = [23,4,7,9,2,14,6,651,87,41,7798,24],</span><br><span class="line">            worker = new Worker(&quot;WebWorkerExample01.js&quot;);   //创建web worker线程             </span><br><span class="line">            worker.onmessage = function(event)&#123;  //onmessage监听接收信息时间</span><br><span class="line">                alert(event.data);   //data是从WebWorkerExample01.js传来的处理后数据</span><br><span class="line">            &#125;;</span><br><span class="line">            worker.postMessage(data);    //将数组的data传给WebWorkerExample01.js     </span><br><span class="line">        &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>WebWorkerExample01.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.onmessage = function(event)&#123;</span><br><span class="line">    var data = event.data;   //这个data应该是页面中已经从ajax或者数组自定义的data</span><br><span class="line">    data.sort(function(a, b)&#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    self.postMessage(data);    //将处理好的data传回网页</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="7-Ajax"><a href="#7-Ajax" class="headerlink" title="7.Ajax"></a>7.Ajax</h1><h3 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a>分析：</h3><p>1.多种方法向服务器请求数据：XHR、script动态脚本注入，iframes，Coment(短轮询服务器接口来回关闭，长轮询时候服务器接口一直打开)，Multipart XHR, CORS，SSE，Web Sockets<br>2.GET请求的数据会被缓存起来，且GET只发送一个数据包，而一个POST请求，至少发送两个数据包，一个装载头信息，另一个装在POST正文，如果请求多次请用GET。POST更适合发送大量数据到服务器，因为不关心额外数据包的数量，另一个原因是对URL长度没有限制，GET是有长度限制的。<br>3.上边有介绍动态脚本注入的方法，缺点是注入失败也不会得到反馈，而且不能访问请求头信息，必须封装在一个function函数内，而且还不安全，但是速度却非常快。<br>4.Multipart XHR是通过给图片加上base64码（这个码就是js内容）来通过XHR进行请求的（因为图片文件是没有安全策略的，还有就是<strong>可以同时传送多个图片，减少http请求次数</strong>，实时执行操作，readyState==3）。缺点：不能被浏览器缓存，老版本IE不支持readyState为3的状态。<br>5.Ajax最大的瓶颈就是Http请求，因此减少其数量会对整个页面的性能有很大的影响。<br>6.图片信标：非常类似动态脚本注入，创建一个新image对象，并把src属性设置为服务器上脚本的URL。该URL包含了我们通过GET传回的键值对数据。服务器回传数据最快且最有效的方式。缺点：无法发送POST，而且URL长度有限制（高性能P133）<br>7.XML：XML及其冗长而且语法有些模糊。<br>8.XPath在解析XML文档时比getElementsByTagName快许多。未被广泛支持，且必须使用旧式DOM遍历方法编写降级的代码。<br>9.JSON可以通过eavl()来解析JSON字符串，但是不推荐用这个，因为在解析的时候会自动执行JSON内部的javascript代码。所以尽可能使用JSON.parse().<br>标准版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;:1,</span><br><span class="line">    &quot;username&quot;:&apos;zhp&apos;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<p>简化版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;i&quot;:1,</span><br><span class="line">    &quot;u&quot;:&apos;zhp&apos;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<p>数组版：文件最小，下载最快，解析速度快出30%<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1,zhp]]</span><br></pre></td></tr></table></figure></p>
<p>10.JSON-P动态注入JSON文件，注入的是源生的javascript，所以文件会增大，不过不用解析，所以文件增大造成的影响是微不足道的。文件大小和下载耗时与XHR比，基本相同，但是解析速度提升了10倍。<br>11.HTML是一种缓慢又臃肿的数据格式。服务器生成HTML速度更快，但是数据占用更多的空间，传给客户端的时候需要很多的带宽。还有就是通过JSON传送客户端，客户端通过javascript来生成HTML。这需要大量的字符串操作，而字符串操作也是javascript中最慢的部分。<br>12.自定义格式：用一些简单的分隔符将数据链接起来，然后通过split()方法将其转化成数组形式。<br><img src="/images/QQ截图20160310141455.jpg" alt=""></p>
<p>13.MXHR能大幅提升性能的主要原因是通过监听readyState为3的状态，我们可以在一个较大的响应还没有完全接受之前把它分段处理，这使得我们可以实时处理响应片段。</p>
<h3 id="优化：-6"><a href="#优化：-6" class="headerlink" title="优化："></a>优化：</h3><p>1.最快的Ajax的请求就是没有请求，所以进行缓存数据，让其不进行缓存。有两种方式<br>方法一：在服务器端，设置HTTP头信息以确保你的响应会被浏览器缓存。（简单好维护，缓存内容可以跨页面和跨会话）<br>Ajax请求必须使用GET请求。<br>Expires头信息格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Mon, 28 Jul 2099 23:30:00 GMT   //设置一个遥远的时间点（不能超过1年），且日期是GMT时间</span><br></pre></td></tr></table></figure></p>
<p>PHP服务器上设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$lifetime = 7*24*60*60;   //7天，按秒计算</span><br><span class="line">header(&apos;Expires: &apos; . gmdate(&apos;D, d M Y H:i:s&apos;, time() + $lifetime) . &apos;GMT&apos;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$lifetime = 7*365*24*60*60;   //10年，按秒计算</span><br><span class="line">header(&apos;Expires: &apos; . gmdate(&apos;D, d M Y H:i:s&apos;, time() + $lifetime) . &apos;GMT&apos;);</span><br></pre></td></tr></table></figure>
<p>方法二：在客户端，将获取到的信息存储到本地，从而避免再次请求。（最大化控制权，废止缓存内容并获取更新）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var localCache = &#123;&#125;;</span><br><span class="line">function xhrRequest(url,callback)&#123;</span><br><span class="line">	//检查此URL的本地缓存</span><br><span class="line">	if(localCache[url])&#123;</span><br><span class="line">		callback.success(localCache[url]);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//此URL对应的缓存没有找到，则发送请求</span><br><span class="line">	var req = createXhrObject();</span><br><span class="line">	req.onerror = function()&#123;</span><br><span class="line">		callback.error();</span><br><span class="line">	&#125;</span><br><span class="line">	req.onreadystatechange = function()&#123;</span><br><span class="line">		if(req.readyState ==4)&#123;</span><br><span class="line">			if(req.responseText === &apos;&apos; || req.status == &apos;404&apos;)&#123;</span><br><span class="line">				callback.error();</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			//存储响应文本到本地缓存</span><br><span class="line">			localCache[url] = req.responseText;</span><br><span class="line">			callback.success(req.responseText);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	req.open(&apos;GET&apos;,url,true);</span><br><span class="line">	req.send(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.减少请求数，合并js和css</p>
<h1 id="8-编程实践"><a href="#8-编程实践" class="headerlink" title="8.编程实践"></a>8.编程实践</h1><p>1.避免双重求值：一段js代码中执行另一段js代码，会导致双重求值的性能消耗。四种方法可能出现这种现象：eval()、Function()构造函数、setTimeout()和setInterval().双重求值比直接包含的代码执行速度慢许多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = eval(&apos;num1 + num2&apos;)  //括号内的字符串会自动运行-双重求值</span><br></pre></td></tr></table></figure></p>
<p>2.无论javascript代码如何优化，都不会比javascript引擎提供的原生方法更快，所以尽量使用原生内置方法，例如Math对象，尽量使用内置属性。<br>3.querySelector()和querySelectorAll()比jQuery获取速度快将近10%。</p>
<h3 id="优化：-7"><a href="#优化：-7" class="headerlink" title="优化："></a>优化：</h3><p>1.建议传入函数而不是字符串–避免双重求值<br>2.创建对象和数组时，使用直接量是最快的方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;&#125;;</span><br><span class="line">var myArr = [];</span><br></pre></td></tr></table></figure></p>
<p>3.避免重复执行：<br>方法一：<br>添加和移除事件处理器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function addHandler(target,eventType,handler)&#123;</span><br><span class="line">	if(target.addEventListener)&#123;</span><br><span class="line">		target.addEventListener(eventType,handler,false)</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		target.attachEvent(&quot;on&quot;+eventType,handler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">function removeHandler(target,eventType,handler)&#123;</span><br><span class="line">	if(target.removeEventListener)&#123;</span><br><span class="line">		target.removeEventListener(eventType,handler,false)</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		target.detachEvent(&quot;on&quot;+eventType,handler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法二：</strong><br>延迟加载-第一次调用进行重写addHandler,第二次调用的就是重写后的addHandler了，引用函数特性！<br>缺点：要执行一次后，下一次的时候才能用新的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function addHandler(target,eventType,handler)&#123;</span><br><span class="line">	if(target.addEventListener)&#123;</span><br><span class="line">		target.addEventListener(eventType,handler,false)</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		target.attachEvent(&quot;on&quot;+eventType,handler);</span><br><span class="line">	&#125;</span><br><span class="line">        addHandler(target,eventType,handler)    //只多了这句重写addHandler</span><br><span class="line">&#125;</span><br><span class="line">function removeHandler(target,eventType,handler)&#123;</span><br><span class="line">	if(target.removeEventListener)&#123;</span><br><span class="line">		target.removeEventListener(eventType,handler,false)</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		target.detachEvent(&quot;on&quot;+eventType,handler);</span><br><span class="line">	&#125;</span><br><span class="line">        removeHandler(target,eventType,handler)    //只多了这句重写removeHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法三：<br>条件预加载-通过三元运算符来一次性重置函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var addHandler = document.body.addEventListener?</span><br><span class="line">	function(target,eventType,handler)&#123;</span><br><span class="line">		target.addEventListener(eventType,handler,false)</span><br><span class="line">	&#125;:</span><br><span class="line">	function(target,eventType,handler)&#123;</span><br><span class="line">		target.attachEvent(eventType,handler,false)</span><br><span class="line">	&#125;;</span><br><span class="line">var removeHandler = document.body.addEventListener?</span><br><span class="line">	function(target,eventType,handler)&#123;</span><br><span class="line">		target.removeEventListener(eventType,handler,false)</span><br><span class="line">	&#125;:</span><br><span class="line">	function(target,eventType,handler)&#123;</span><br><span class="line">		target.detachEvent(eventType,handler,false)</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure></p>
<p>3.位操作-通过转化为2进制（toString(2)），然后通过对0/1判断true或者false<br>速度比原始版本快50%<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">25.toString(2);//11001</span><br><span class="line">3.toString(2);//11</span><br><span class="line">25&amp;3 //1  为真</span><br><span class="line"></span><br><span class="line">if(i%2)&#123; &#125;   //一直在0/1之间切换，所以可以用来做切换判断</span><br><span class="line">if(i&amp;1)&#123; &#125;   //效果和上边相同</span><br></pre></td></tr></table></figure></p>
<p>4.文件复用：像html，css等的复用，换肤，reset，报错页面，播放器或音乐<br>5.模块复用：用js绘制header，footer 。 iframe一般都是嵌入广告，先把文件拿过来，再去请求，浪费资源<br>6.分级加载：重要的先加载，视频-&gt;广告-&gt;评论，所以这些最好通过异步来加载<br>7.按需加载：惰性加载-滑倒底部后进行加载    </p>
<h1 id="9-BigPipe"><a href="#9-BigPipe" class="headerlink" title="9.BigPipe"></a>9.BigPipe</h1><p>重要的东西同步加载，不重要的东西异步加载–首屏重要可以先加载，然后再加载下边的<br>下载时间不会缩短，只是做到按需加载，通过异步，先加载重要的，其他的通过异步加载<br>参考文献：<br><a href="http://www.cnblogs.com/mofish/archive/2011/11/03/2234858.html" target="_blank" rel="external">http://www.cnblogs.com/mofish/archive/2011/11/03/2234858.html</a><br>原理：<br>占位符：一个空的div，留着用js通过异步插入内容<br>textarea：通过后端把要传入的数据打到前端textarea内，textarea不会解析源码，当调用的时候取出来，平时用display：none来隐藏</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1.连接数增多，如果dns不好，比如国外用户，每次链接成本都很高，那很不适合<br>2.爬虫只能爬到html，接口返回的内容是爬不到的，爬接口的话，如果ip不是本域的话，是没有cookie，就是没有session权限的，也是没法获取的。还有就是如果通过跨域的话，如果请求量过高的话，服务器会把爬虫禁止掉的，因为会爬缓存和数据库，对服务器压力很大，所以爬虫只能爬到有占位符的文档<br>3.因为都是异步的，所以通信顺序就很难把握，做加载队列，又很麻烦<br>4.通过后端渲染到textarea里，然后就不用重复去请求服务器，但是如果有三个模块用到一个url的时候，就需要用一些观察者模式的方法，或者hashMap</p>
<h1 id="10-构建并部署高性能javascript应用"><a href="#10-构建并部署高性能javascript应用" class="headerlink" title="10.构建并部署高性能javascript应用"></a>10.构建并部署高性能javascript应用</h1><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>1.合并多个javascript文件<br>2.javaScript文件压缩<br>3.javascript的HTTP压缩。web浏览器请求资源时，通常会发送一个Accept-Encoding HTTP头来告诉Web服务器它支持哪种编码转换类型。<br>Accept-Encoding可用的值包括gzip、compress、deflate、identity。服务器看到这个请求头会选择最适合的编码方法，并通过Content-Encoding HTTP头通知客户端它的决定。<br>4.Gzip最流行的编码格式，减少70%下载量，提升性能的<strong>首选武器</strong>。图片或者PDF文件不应该使用Gzip压缩，因为他们本身已经被压缩过了。（高性能P170）<br>5.缓存javascript文件。通过Expires HTTP响应头。日期不应超过1年。手机端会有缓存大小限制，最好不要超过15k，超过15k可以拆分多个文件进行缓存，但是这样的话HTTP连接数就会增加，所以也是视具体情况而定。<br>设置过期时间有两种方法：<br>第一种：在HTTP头部直接设置时间。P146<br>第二种：Apache web server有ExpiresDefault指令，也可以通过这种方法来设置时间。P172<br>6.HTML5的manifest file是一种更好的方法，不会有Expires的问题。<br>7.可以通过添加时间戳来更新缓存<br>8.内容发布到CDN上-但是如果国外访问,DNS查询成本太高，有可能会更慢.<br>9.keep-alive 正常http有三次握手，同一个域名或ip复用，沿用之前的路径<br>10.cache-static 当访问不到的时候，也要给静态页面，让能看到完整的页面</p>
<h1 id="11-DNS寻址及IP解析"><a href="#11-DNS寻址及IP解析" class="headerlink" title="11.DNS寻址及IP解析"></a>11.DNS寻址及IP解析</h1><p>当输入一个IP地址进行访问一个网站时候，最好设置一个301跳转将这个地址跳转到域名下，然后再通过域名再分配一个离用户最近的服务器或者网路最好的机房，这样访问速度就会更快<br>301和302跳转的区别：301为永久性跳转，302为临时性跳转，对seo不利<br>每次客户登陆的时候，都会产生一个cookie，当链接服务器的时候，发送给服务器，被认为是一个合法用户<br>域名解析方法是从右向左的，先解析的是.这个.是公网，最最外层的域名，然后才是com<br>一般运营商都会有一个自己的网址地图Hash Map,所以一般不用加.最后<br>TCP是传输协议，倒数第四层，IP属于网络层的协议，进行寻址，倒数第三层</p>
<h1 id="12-调试工具"><a href="#12-调试工具" class="headerlink" title="12.调试工具"></a>12.调试工具</h1><h2 id="Chrome命令"><a href="#Chrome命令" class="headerlink" title="Chrome命令"></a>Chrome命令</h2><p>1.查找文件或内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+P</span><br></pre></td></tr></table></figure></p>
<p>2.在文档内查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+F</span><br></pre></td></tr></table></figure></p>
<p>3.保存Console<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Console面板右边有一个Preserve log勾选上</span><br></pre></td></tr></table></figure></p>
<p>4.格式化压缩过的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 点这个符号</span><br></pre></td></tr></table></figure></p>
<p>5.选择下一个匹配项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+D</span><br></pre></td></tr></table></figure></p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><p>1.通过new Date()测量脚本运行时间。<br>2.分析匿名函数的最佳办法：是给他们取个名字，使用指针指向对象的方法。<br>通过下边这种方法这个匿名函数在Chrome这种调试工具中就有名字了。<br>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myNode.onclick = function newName()&#123;   //给这个匿名函数添加个名字newName</span><br><span class="line">	myApp.loadData();</span><br><span class="line">&#125;</span><br><span class="line">var onClick = function newName2()&#123;    //给声明为变量onClick的匿名函数添加个名字newName2</span><br><span class="line">	myApp.loadData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：（自己推测并未考证）<br>通过new Date()方法，让匿名函数自执行来求运行时间。<br>3.查看栈的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.trace()</span><br></pre></td></tr></table></figure></p>
<p>4.输出数组数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.table(arr)</span><br></pre></td></tr></table></figure></p>
<p>5.测试函数运行时间–也可以测循环语句时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time()</span><br><span class="line">函数</span><br><span class="line">console.timeEnd()</span><br></pre></td></tr></table></figure></p>
<p>6.测试更复杂的函数且显示更详细的问题-配合Profiles查看。<br>将profileEnd()调用封装在setTimeout中,使得可以异步生成报告，而不阻塞脚本执行。<br>结果：显示每个函数所花的时间，调用的次数，占总开销的百分比，及其他更多数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.profile()</span><br><span class="line">函数</span><br><span class="line">console.profileEnd()</span><br></pre></td></tr></table></figure>
<p>7.Chrome网络面板<br>每个资源后面的色块条将加载过程分解为不同阶段（DNS查找、等待响应）<br>蓝色表示页面DOMContentLoad时间触发的时刻。红色表示window的load事件触发的时刻。<br>每个脚本都在等待前一个脚本下载完成后才发起下一个请求。<br>8.Profiles<br>1.Collect Javascript CPU Profile<br>查看javascript CPU使用情况<br>2.Take Heap Snapshot(一般查看这个)<br>查看栈堆对象及相关DOM节点内存分配<br>用法：运行start，然后执行事件，再点击左上角黑圆点图标进行快照比较<br>3.Record Heap Allocations<br>记录对象分配超时，隔离内存泄漏<br><strong>9.Timeline</strong><br>网络和HTML解析(蓝色)，JavaScript(黄色)，样式重计算和布局(紫色)以及绘画和合成(绿色)事件<br>参考文章：<a href="http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles" target="_blank" rel="external">http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles</a><br>10.更多Chrome使用技巧<br>参考文章：<a href="https://github.com/ChenChenJoke/JokerChrome" target="_blank" rel="external">https://github.com/ChenChenJoke/JokerChrome</a></p>
<h1 id="13-测试工具"><a href="#13-测试工具" class="headerlink" title="13.测试工具"></a>13.测试工具</h1><p>1.YSlow工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://yslow.org/</span><br></pre></td></tr></table></figure></p>
<p>2.奇云测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ce.cloud.360.cn/</span><br></pre></td></tr></table></figure></p>
<p>3.阿里测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.alibench.com/</span><br></pre></td></tr></table></figure></p>
<p>4.百度应用性能检测中心<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://developer.baidu.com/apm/</span><br></pre></td></tr></table></figure></p>
<p>5.Web PageTest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.webpagetest.org/</span><br></pre></td></tr></table></figure></p>
<h1 id="14-雅虎军规"><a href="#14-雅虎军规" class="headerlink" title="14.雅虎军规"></a>14.雅虎军规</h1><p>1.[内容]尽量减少HTTP请求数<br>2.[服务器]使用CDN（Content Delivery Network）<br>3.[服务器]添上Expires或者Cache-Control HTTP头<br>4.[服务器]Gzip组件<br>5.[css]把样式表放在顶部<br>6.[js]把脚本放在底部<br>7.[css]避免使用CSS表达式<br>8.[js, css]把JavaScript和CSS放到外面<br>9.[内容]减少DNS查找<br>10.[js, css]压缩JavaScript和CSS<br>11.[内容]避免重定向<br>12.[js]去除重复脚本<br>13.[服务器]配置ETags<br>14.[内容]让Ajax可缓存<br>15.[服务器]尽早清空缓冲区<br>16.[服务器]对Ajax用GET请求<br>17.[内容]延迟加载组件<br>18.[内容]预加载组件<br>19.[内容]减少DOM元素的数量<br>20.[内容]跨域分离组件<br>21.[内容]尽量少用iframe<br>22.[内容]杜绝404<br>23.[cookie]给Cookie减肥<br>24.[cookie]把组件放在不含cookie的域下<br>25.[js]尽量减少DOM访问<br>26.[js]用智能的事件处理器<br>27.[css]选择 舍弃@import<br>28.[css]避免使用滤镜<br>29.[图片]优化图片<br>30.[图片]优化CSS Sprite<br>31.[图片]不要用HTML缩放图片<br>32.[图片]用小的可缓存的favicon.ico（P.S. 收藏夹图标）<br>33.[移动端]保证所有组件都小于25K<br>34.[移动端]把组件打包到一个复合文档里<br>35.[服务器]避免图片src属性为空<br>翻译：<a href="http://www.tuicool.com/articles/J3uyaa" target="_blank" rel="external">http://www.tuicool.com/articles/J3uyaa</a><br>官网：<a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">https://developer.yahoo.com/performance/rules.html</a></p>
<p><strong>雅虎军规不适用的地方：</strong><br>视频网站，先加载视频，浏览器是默认后加载，如果视频网视频后出来就不太符合了<br>游戏的话，要让背景和声音先出来而不能让数字先出来<br>多域名拆分cdn，在国外不适用<br><img src="/images/前端性能优化.png" alt=""></p>

					</div>


					<div class="content-tag">

<a class="tag-link" href="/tags/javascript/">javascript</a>, <a class="tag-link" href="/tags/note/">note</a>, <a class="tag-link" href="/tags/笔记/">笔记</a>

					</div>



				</article>
			</div>

		</div>

		<div class="panel-post-nav">
			<div class="box-post-nav">


					<a href="/2016/03/20/javascript高级程序设计-笔记/" title="javascript高级程序设计---笔记">&larr; Prev</a>



					<a href="/2016/03/20/javascript数据结构与算法-笔记/" title="javascript数据结构与算法---笔记">Next &rarr;</a>


			</div>
		</div>
		<div class="content-comments">
		
  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/20/javascript高性能-笔记/index.html" data-title="javascript高性能---笔记" data-url="/2016/03/20/javascript高性能-笔记/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'pengweb'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  
		</div>
		

	</div>

	<div class="layout-footer" style="clear: both">
		<div class="panel-footer">
			<div class="box-footer">
				<footer class="footer">
					<p class="cr">&copy; 2016 <a href="https://github.com/pengweb"  target="_blank" target="_blank">Pengzhang</a> 
					<span class="theme">Powered: <a href="https://github.com/pengweb/pengweb.github.io" target="_blank">pengweb.net</a>, 京ICP备: <a href="" target="_blank">15017479</a></span>
					</p>

					
				</footer>
			</div>
		</div>
	</div>




</body>
</html>
