<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title> javascript数据结构与算法--学习笔记 | 张鹏的全栈之路 </title>
	<meta property="og:title" content=" javascript数据结构与算法--学习笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:title" content=" javascript数据结构与算法--学习笔记 | 张鹏的全栈之路 ">

	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary">

	<meta name="description" content=" javascript数据结构与算法--学习笔记 | 张鹏的全栈之路 ">
	<meta property="og:description" content=" javascript数据结构与算法--学习笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:description" content=" javascript数据结构与算法--学习笔记 | 张鹏的全栈之路 " />

	<link rel="icon" type="image/x-icon" href="/asset/img/favicon.png">

	<link rel="image_src" href="/asset/img/logo.png" >
	<meta property="og:image" content="/asset/img/logo.png" />

	<link href="http://yoursite.com/atom.xml" title="张鹏的全栈之路" type="application/atom+xml" rel="alternative">

	<link rel="canonical" href="/2016/03/20/javascript数据结构与算法--学习笔记(冲突时的文件备份2016-04-15 09-22-02)/index.html">

	<link rel="stylesheet" href="/asset/css/style.css">

</head>

<body>

	<div class="layout-header">
		<header class="header">
			<div class="layout-logo">
				<div class="panel-logo">

					<div class="box-logo box-log-md">
						<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
					</div>
					<div class="box-main-title">
						<h5 style="text-align: center">
							<span>Love life,love ourselves！--Pengzhang</span>
						</h5>
					</div>
					<div class="box-sub-title">

					</div>
				</div>
			</div>
			<div class="layout-menu">
				<div class="box-logo box-log-xs">
					<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
				</div>
				<div class="box-menu-list">
					<nav class="page-nav">
						<ul class="menu-list">

							<li class="box-menu-item"><a href="/"><span class="menu-item">HOME</span></a></li>

							<li class="box-menu-item"><a href="/tags/js"><span class="menu-item">Javascript</span></a></li>

							<li class="box-menu-item"><a href="/tags/nodejs"><span class="menu-item">Node.js</span></a></li>

							<li class="box-menu-item"><a href="/tags/html"><span class="menu-item">Html</span></a></li>

							<li class="box-menu-item"><a href="/tags/css"><span class="menu-item">Css</span></a></li>

							<li class="box-menu-item"><a href="/tags/note"><span class="menu-item">Note</span></a></li>

							<li class="box-menu-item"><a href="/tags/others"><span class="menu-item">Others</span></a></li>

						</ul>
					</nav>

				</div>
			</div>
		</header>
	</div>

	<div class="layout-content">


		<div class="row panel-content panel-post-item">
			<div class="box-post-item">
				<article class="post-item" itemscope itemtype="http://schema.org/Article">




					<p class="content-meta">
						<span class="meta-date" itemprop="datePublished" content="2016-03-20">2016-03-20</span>


					</p>


					<h2 class="box-content-title">
						<a href="/2016/03/20/javascript数据结构与算法--学习笔记(冲突时的文件备份2016-04-15 09-22-02)/"  itemprop="url"><span class="content-title" itemprop="name">javascript数据结构与算法--学习笔记</span></a>
					</h2>

					<div class="content post-item-content" itemprop="articleBody">

<h1 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h1><h1 id="2-堆"><a href="#2-堆" class="headerlink" title="2.堆"></a>2.堆</h1><h1 id="3-基本算法"><a href="#3-基本算法" class="headerlink" title="3.基本算法"></a>3.基本算法</h1><p><a href="http://www.imooc.com/article/4543" target="_blank" rel="external">http://www.imooc.com/article/4543</a><br><a href="http://www.imooc.com/article/4593" target="_blank" rel="external">http://www.imooc.com/article/4593</a><br><a href="http://www.imooc.com/article/4695" target="_blank" rel="external">http://www.imooc.com/article/4695</a><br><a href="http://www.imooc.com/article/4713" target="_blank" rel="external">http://www.imooc.com/article/4713</a></p>
<h1 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h1><h1 id="12-二进制数组"><a href="#12-二进制数组" class="headerlink" title="12.二进制数组"></a>12.二进制数组</h1><p>二进制数组（ArrayBuffer对象、TypedArray视图和DataView视图）是JavaScript操作二进制数据的一个接口。<br>这个接口的原始设计目的，与WebGL项目有关。所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。<br>这时要是存在一种机制，可以像C语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。<br>二进制数组由<strong>三类对象</strong>组成。<br>（1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</p>
<p>（2）TypedArray视图：共包括9种类型的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float32Array（32位浮点数）数组视图等等。</p>
<p>（3）DataView视图：可以自定义复合格式的视图，比如第一个字节是Uint8（无符号8位整数）、第二、三个字节是Int16（16位整数）、第四个字节开始是Float32（32位浮点数）等等，此外还可以自定义字节序。</p>
<p><strong>简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。</strong></p>
<h1 id="13-Set和Map数据结构"><a href="#13-Set和Map数据结构" class="headerlink" title="13.Set和Map数据结构"></a>13.Set和Map数据结构</h1><h2 id="13-1-Set"><a href="#13-1-Set" class="headerlink" title="13.1 Set"></a>13.1 Set</h2><h3 id="13-1-1-基本用法"><a href="#13-1-1-基本用法" class="headerlink" title="13.1.1 基本用法"></a>13.1.1 基本用法</h3><p>ES6提供了新的数据结构Set。<br>它<strong>类似于数组</strong>，但是成员的值都是<strong>唯一</strong>的，<strong>没有重复</strong>的值。<br>Set本身是一个<strong>构造函数</strong>，用来生成Set数据结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>].map(x =&gt; s.add(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;<span class="built_in">console</span>.log(i)&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码通过add方法向Set结构加入成员，结果表明Set结构<strong>不会添加重复的值</strong>。</p>
<p>Set函数可以接受一个数组（或类似数组的对象）作为<strong>参数</strong>，用来初始化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.size <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(divs())</span><br><span class="line">set.size <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line">divs().forEach(div =&gt; set.add(div))</span><br><span class="line">set.size <span class="comment">// 56</span></span><br></pre></td></tr></table></figure></p>
<p>向Set加入值的时候，<strong>不会发生类型转换</strong>，所以5和”5”是两个不同的值。<br>Set内部判断两个值<strong>是否不同</strong>，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是<strong>NaN等于自身</strong>，而精确相等运算符认为NaN不等于自身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span>;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set <span class="comment">// Set &#123;NaN&#125;   同一个值，所以只有一个</span></span><br></pre></td></tr></table></figure></p>
<p>另外，两个<strong>对象</strong>总是不相等的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;)</span><br><span class="line">set.size <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;)</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="13-1-2-Set实例的属性和方法"><a href="#13-1-2-Set实例的属性和方法" class="headerlink" title="13.1.2 Set实例的属性和方法"></a>13.1.2 Set实例的属性和方法</h3><p>Set结构的实例有以下属性。</p>
<p><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。<br><code>Set.prototype.size</code>：返回Set实例的成员总数。<br>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<p><code>add(value)</code>：添加某个值，返回Set结构本身。<br><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code>：清除所有成员，没有返回值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="keyword">var</span> properties = &#123;</span><br><span class="line">  <span class="string">"width"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"height"</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties[someName]) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set的写法</span></span><br><span class="line"><span class="keyword">var</span> properties = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">properties.add(<span class="string">"width"</span>);</span><br><span class="line">properties.add(<span class="string">"height"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties.has(someName)) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Array.from</code>方法可以将Set结构<code>转为数组</code>。<br><strong>可以有效的通过这个方法来去重</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">var</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure></p>
<h3 id="13-1-3-遍历操作"><a href="#13-1-3-遍历操作" class="headerlink" title="13.1.3 遍历操作"></a>13.1.3 遍历操作</h3><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<p><code>keys()</code>：返回一个键名的遍历器<br><code>values()</code>：返回一个键值的遍历器<br><code>entries()</code>：返回一个键值对的遍历器<br><code>forEach()</code>：使用回调函数遍历每个成员</p>
<p>由于Set结构<strong>没有键名</strong>，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> item <span class="keyword">of</span> set.values() )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> item <span class="keyword">of</span> set.entries() )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></table></figure></p>
<p>Set结构的实例默认可遍历，它的<strong>默认</strong>遍历器生成函数就是它的values方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>这意味着，可以<strong>省略values</strong>方法，直接用for…of循环遍历Set。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;           <span class="comment">//省略value</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p>
<p>由于<strong>扩展运算符（…）内部使用for…of循环</strong>，所以也可以用于Set结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">// ['red', 'green', 'blue']</span></span><br></pre></td></tr></table></figure></p>
<p>这就提供了另一种便捷的<strong>去除数组重复元素</strong>的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure></p>
<p>而且，数组的map和filter方法也可以用于Set了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(x =&gt; x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(x =&gt; (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>因此使用Set，可以很容易地实现<strong>并集（Union）、交集（Intersect）和差集（Difference）</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(x =&gt; b.has(x)));</span><br><span class="line"><span class="comment">// [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></p>
<p>Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set.forEach((value, key) =&gt; <span class="built_in">console</span>.log(value * <span class="number">2</span>) )</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码说明,forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。<br>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure></p>
<h2 id="13-2-WeakSet"><a href="#13-2-WeakSet" class="headerlink" title="13.2 WeakSet"></a>13.2 WeakSet</h2><p>WeakSet结构与Set类似，也是<strong>不重复</strong>的值的集合。但是，它与Set有两个区别。</p>
<ol>
<li>WeakSet的成员<strong>只能是对象</strong>，而不能是其他类型的值。</li>
<li>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是<strong>不可遍历</strong>的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>)           <span class="comment">//只能放置对象，所以报错</span></span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>())    <span class="comment">//Symbol()是新的数据类型也不是对象</span></span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>WeakSet是一个<strong>构造函数</strong>，可以使用new命令，创建WeakSet数据结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br></pre></td></tr></table></figure>
<p>上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会<strong>自动成为WeakSet的成员</strong>。<br><strong>是a数组的成员成为WeakSet的成员，而不是a数组本身。</strong><br>这意味着，数组的<strong>成员只能是对象</strong>。<br>WeakSet结构有以下三个方法。</p>
<p><code>WeakSet.prototype.add(value)</code>：向WeakSet实例添加一个新成员。<br><code>WeakSet.prototype.delete(value)</code>：清除WeakSet实例的指定成员。<br><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在WeakSet实例之中。</p>
<p>WeakSet<strong>没有</strong> <code>size</code>属性，没有办法遍历它的成员。<br>WeakSet不能遍历，是因为成员都是<strong>弱引用，随时可能消失</strong>，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。<br>WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。</p>
<h2 id="13-3-Map"><a href="#13-3-Map" class="headerlink" title="13.3 Map"></a>13.3 Map</h2><h3 id="13-3-1-Map结构的目的和基本用法"><a href="#13-3-1-Map结构的目的和基本用法" class="headerlink" title="13.3.1 Map结构的目的和基本用法"></a>13.3.1 Map结构的目的和基本用法</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。这给它的使用带来了很大的限制。<br>ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围<strong>不限于字符串</strong>，各种类型的值（包括对象）都可以当作键。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">var</span> o = &#123;p: <span class="string">"Hello World"</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">"content"</span>)</span><br><span class="line">m.get(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>, <span class="string">"张三"</span>], [<span class="string">"title"</span>, <span class="string">"Author"</span>]]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">"name"</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">"name"</span>) <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">"title"</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">"title"</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure></p>
<p>如果对同一个键多次赋值，后面的值将<strong>覆盖</strong>前面的值。<br>如果读取一个<strong>未知的键</strong>（没有定义过的），则返回<code>undefined</code>。<br>只有对同一个对象的引用，Map结构才将其视为同一个键。<br>同样的值的两个实例，在Map结构中被视为两个键。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined     这两个['a']内存地址是不同的？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k1 = [<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">var</span> k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure></p>
<p><strong>由此可知Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="number">-0</span>, <span class="number">123</span>);</span><br><span class="line">map.get(+<span class="number">0</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<h3 id="13-3-2-实例的属性和操作方法"><a href="#13-3-2-实例的属性和操作方法" class="headerlink" title="13.3.2 实例的属性和操作方法"></a>13.3.2 实例的属性和操作方法</h3><p>（1）size属性<br>size属性返回Map结构的成员总数。</p>
<p>（2）set(key, value)<br>set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。<br>set方法返回的是Map本身，因此可以采用<strong>链式</strong>写法。</p>
<p>（3）get(key)<br>get方法读取key对应的键值，如果找不到key，返回undefined。</p>
<p>（4）has(key)<br>has方法返回一个布尔值，表示某个键是否在Map数据结构中。</p>
<p>（5）delete(key)<br>delete方法删除某个键，返回true。如果删除失败，返回false。</p>
<p>（6）clear()<br>clear方法清除所有成员，没有返回值。</p>
<h3 id="13-3-3-遍历方法"><a href="#13-3-3-遍历方法" class="headerlink" title="13.3.3 遍历方法"></a>13.3.3 遍历方法</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>
<p><code>keys()</code>：返回键名的遍历器。<br><code>values()</code>：返回键值的遍历器。<br><code>entries()</code>：返回所有成员的遍历器。<br><code>forEach()</code>：遍历Map的所有成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</span><br><span class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F"</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "no"</span></span><br><span class="line"><span class="comment">// "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码最后的那个例子，表示Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="built_in">Symbol</span>.iterator] === map.entries</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>Map结构<strong>转为数组</strong>结构，比较快速的方法是结合使用<strong>扩展运算符</strong>（…）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>结合数组的map方法、filter方法，可以实现Map的遍历和过滤（<strong>Map本身没有map和filter方法</strong>）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].filter(([k, v]) =&gt; k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].map(([k, v]) =&gt; [k * <span class="number">2</span>, <span class="string">'_'</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。<br>forEach方法还可以接受<strong>第二个参数</strong>，用来绑定<code>this</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reporter = &#123;</span><br><span class="line">  report: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></p>
<h3 id="13-3-4-与其他数据结构的互相转换"><a href="#13-3-4-与其他数据结构的互相转换" class="headerlink" title="13.3.4 与其他数据结构的互相转换"></a>13.3.4 与其他数据结构的互相转换</h3>
					</div>


					<div class="content-tag">

<a class="tag-link" href="/tags/javascript/">javascript</a>, <a class="tag-link" href="/tags/js/">js</a>, <a class="tag-link" href="/tags/note/">note</a>, <a class="tag-link" href="/tags/笔记/">笔记</a>

					</div>



				</article>
			</div>

		</div>

		<div class="panel-post-nav">
			<div class="box-post-nav">


					<a href="/2016/03/20/javascript数据结构与算法--学习笔记/" title="javascript数据结构与算法--学习笔记">&larr; Prev</a>



					<a href="/2016/03/20/Markdown语法总结/" title="Markdown语法总结">Next &rarr;</a>


			</div>
		</div>
		<div class="content-comments">
		
  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/20/javascript数据结构与算法--学习笔记(冲突时的文件备份2016-04-15 09-22-02)/index.html" data-title="javascript数据结构与算法--学习笔记" data-url="/2016/03/20/javascript数据结构与算法--学习笔记(冲突时的文件备份2016-04-15 09-22-02)/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'pengweb'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  
		</div>
		

	</div>

	<div class="layout-footer" style="clear: both">
		<div class="panel-footer">
			<div class="box-footer">
				<footer class="footer">
					<p class="cr">&copy; 2016 <a href="https://github.com/pengweb"  target="_blank" target="_blank">Pengzhang</a> 
					<span class="theme">Powered: <a href="https://github.com/pengweb/pengweb.github.io" target="_blank">pengweb.net</a>, 京ICP备: <a href="" target="_blank">15017479</a></span>
					</p>

					
				</footer>
			</div>
		</div>
	</div>




</body>
</html>
