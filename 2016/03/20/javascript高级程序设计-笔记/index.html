<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title> javascript高级程序设计---笔记 | 张鹏的全栈之路 </title>
	<meta property="og:title" content=" javascript高级程序设计---笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:title" content=" javascript高级程序设计---笔记 | 张鹏的全栈之路 ">

	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary">

	<meta name="description" content=" javascript高级程序设计---笔记 | 张鹏的全栈之路 ">
	<meta property="og:description" content=" javascript高级程序设计---笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:description" content=" javascript高级程序设计---笔记 | 张鹏的全栈之路 " />

	<link rel="icon" type="image/x-icon" href="/asset/img/favicon.png">

	<link rel="image_src" href="/asset/img/logo.png" >
	<meta property="og:image" content="/asset/img/logo.png" />

	<link href="http://yoursite.com/atom.xml" title="张鹏的全栈之路" type="application/atom+xml" rel="alternative">

	<link rel="canonical" href="/2016/03/20/javascript高级程序设计-笔记/index.html">

	<link rel="stylesheet" href="/asset/css/style.css">

</head>

<body>

	<div class="layout-header">
		<header class="header">
			<div class="layout-logo">
				<div class="panel-logo">

					<div class="box-logo box-log-md">
						<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
					</div>
					<div class="box-main-title">
						<h5 style="text-align: center">
							<span>Love life,love ourselves！--Pengzhang</span>
						</h5>
					</div>
					<div class="box-sub-title">

					</div>
				</div>
			</div>
			<div class="layout-menu">
				<div class="box-logo box-log-xs">
					<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
				</div>
				<div class="box-menu-list">
					<nav class="page-nav">
						<ul class="menu-list">

							<li class="box-menu-item"><a href="/"><span class="menu-item">HOME</span></a></li>

							<li class="box-menu-item"><a href="/tags/js"><span class="menu-item">Javascript</span></a></li>

							<li class="box-menu-item"><a href="/tags/nodejs"><span class="menu-item">Node.js</span></a></li>

							<li class="box-menu-item"><a href="/tags/html"><span class="menu-item">Html</span></a></li>

							<li class="box-menu-item"><a href="/tags/css"><span class="menu-item">Css</span></a></li>

							<li class="box-menu-item"><a href="/tags/note"><span class="menu-item">Note</span></a></li>

							<li class="box-menu-item"><a href="/tags/others"><span class="menu-item">Others</span></a></li>

							<li class="box-menu-item"><a href="/archives"><span class="menu-item">Sitemap</span></a></li>

						</ul>
					</nav>

				</div>
			</div>
		</header>
	</div>

	<div class="layout-content">


		<div class="row panel-content panel-post-item">
			<div class="box-post-item">
				<article class="post-item" itemscope itemtype="http://schema.org/Article">




					<p class="content-meta">
						<span class="meta-date" itemprop="datePublished" content="2016-03-20">2016-03-20</span>


					</p>


					<h2 class="box-content-title">
						<a href="/2016/03/20/javascript高级程序设计-笔记/"  itemprop="url"><span class="content-title" itemprop="name">javascript高级程序设计---笔记</span></a>
					</h2>

					<div class="content post-item-content" itemprop="articleBody">

<p>3.4.1 typeof没总结</p>
<h1 id="1-javascript简介"><a href="#1-javascript简介" class="headerlink" title="1.javascript简介"></a>1.javascript简介</h1><h4 id="1-2-2-2-DOM级别"><a href="#1-2-2-2-DOM级别" class="headerlink" title="1.2.2.2 DOM级别"></a>1.2.2.2 DOM级别</h4><p>DOM1级由两个模块组成：<br>DOM核心：规定是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。<br>DOM HTML：在DOM核心基础上加以扩展，添加了针对HTML的对象和方法。</p>
<p>DOM2又扩充了鼠标和用户界面事件、范围、遍历等细分模块。<br>DOM2新模块：DOM视图、DOM事件、DOM样式、DOM遍历和范围</p>
<p>DOM3又进一步扩展了DOM，引入了以统一方式加载和保存文档的方法、新增了验证文档的方法、支持XML1.0规范</p>
<h1 id="2-在HTML中使用javascript"><a href="#2-在HTML中使用javascript" class="headerlink" title="2.在HTML中使用javascript"></a>2.在HTML中使用javascript</h1><h2 id="2-1-script"><a href="#2-1-script" class="headerlink" title="2.1 script"></a>2.1 script</h2><p>带有src属性的script标签，开始结束标签之间包含的额外javascript代码，将被忽略不执行。</p>
<h3 id="2-1-2-延迟脚本"><a href="#2-1-2-延迟脚本" class="headerlink" title="2.1.2 延迟脚本"></a>2.1.2 延迟脚本</h3><p>defer属性的脚本，延迟到遇到<code>&lt;/html&gt;</code>标签后执行，且会先于DOMContentLoaded执行。<br>同样带有defer属性的脚本，HTML5规范要求脚本是按顺序执行的，但现实中却无法按顺序执行，无法判断谁先执行。</p>
<h3 id="2-1-3-异步脚本"><a href="#2-1-3-异步脚本" class="headerlink" title="2.1.3 异步脚本"></a>2.1.3 异步脚本</h3><p>async属性的脚本，一定会在页面的load事件前执行，但可能会在DOMContentloaded事件触发之前或之后执行。<br>理论和现实中都是无法控制顺序的。</p>
<h2 id="2-4-noscript"><a href="#2-4-noscript" class="headerlink" title="2.4 noscript"></a>2.4 noscript</h2><p>不支持js的浏览器，平稳退化<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>本页面不支持javascript<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3.基本概念"></a>3.基本概念</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2 标识符"></a>3.1.2 标识符</h3><p>标识符：变量、函数、属性的名字或者函数的参数。</p>
<h3 id="3-1-4严格模式"><a href="#3-1-4严格模式" class="headerlink" title="3.1.4严格模式"></a>3.1.4严格模式</h3><p>“use strict”<br>ES3中不确定的行为将得到处理，对某些不安全的操作会抛出错误。</p>
<h2 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a>3.2 关键字</h2><p>具有特殊用途的关键字：var、new 等等</p>
<h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h2><p>基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code><br>引用数据类型：<code>Object</code></p>
<h3 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2 Undefined类型"></a>3.4.2 Undefined类型</h3><p>只声明，并未初始化的值<br>var声明，但不赋值（不初始化）</p>
<h3 id="3-4-3-Null类型"><a href="#3-4-3-Null类型" class="headerlink" title="3.4.3 Null类型"></a>3.4.3 Null类型</h3><p>不存在的值，但是他表示的是一个<strong>空对象</strong>指针，所以typeof返回的是’object’<br>如果定义变量准备在将来用于保存<strong>对象</strong>，那么最好将该变量初始化为null。<br>undefined<strong>派生</strong>自null，所以 null == undefined   //true</p>
<h3 id="3-4-4-Boolean类型"><a href="#3-4-4-Boolean类型" class="headerlink" title="3.4.4 Boolean类型"></a>3.4.4 Boolean类型</h3><p>区分大小写<br>true不一定等于1，false也不一定等于0<br><code>Boolean()</code>  可以转化Boolean值<br><strong>转化为false的值有：</strong><br>false、””、0或NAN、null、undefined<br><strong>转换为true的值有：</strong><br>任何非空字符串、任何非零数字值(包括无穷大)、任何对象、n/a-意思是不适用</p>
<h3 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5 Number类型"></a>3.4.5 Number类型</h3><p>浮点值也叫双精度数值<br>八进制第一位必须是0，如果字面值中的数值超出范围，那么前导零将被忽略，后面数值将被当作十进制数值进行解析<br>八进制字面量在严格模式下是无效的，抛出异常<br>十六进制前两位必须是0x，后边字符可大写也可小写<br>进行计算时，所有八进制和十六进制都会转换成十进制数值<br>+0 和 -0 是相等的</p>
<h4 id="3-4-5-1-浮点值"><a href="#3-4-5-1-浮点值" class="headerlink" title="3.4.5.1 浮点值"></a>3.4.5.1 浮点值</h4><p>必须包含一个小数点，小数点后至少有一位数字<br>1.1、0.1、.1  都有效<br>浮点值占用内存空间是整数值的<strong>两倍</strong><br>10.0这个浮点数，系统会在动转换为10这个整数值<br>极大或者极小可以用e（科学记数法）表示浮点值<br>e表示10的7次幂<br>3.125e7     //3.1250000<br>ES会将小数点后面至少6位的数值转化为e表示法<br>浮点值最高精度为17位小数，虽然到了17位但精度却远远不如证书。<br>0.1+0.2 = 0.30000000000000004   //判断测试将不通过，所以永远不要测试某个特定的浮点数值</p>
<h4 id="3-4-5-2-数值范围"><a href="#3-4-5-2-数值范围" class="headerlink" title="3.4.5.2 数值范围"></a>3.4.5.2 数值范围</h4><p>最小数值保存在Number.MIN_VALUE中，为<code>5e-324</code><br>最大数值保存在Number.MAX_VALUE中，为<code>1.7976931348623157e+308</code><br>如果超出这个值用<code>Infinity</code>表示，负数用-Infinity表示</p>
<h4 id="3-4-5-3-NaN"><a href="#3-4-5-3-NaN" class="headerlink" title="3.4.5.3 NaN"></a>3.4.5.3 NaN</h4><p>特殊数值，表示要返回数值的操作数未返回数值的情况<br>1.任何数值除以<strong>非数值</strong>会返回NaN<br>2.<strong>NaN与任何值都不相等，包括自身</strong><br>isNaN(),尝试将这个值<strong>转化为数值</strong>，确定这个参数是否”不是数值”。不能转化的为true<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">"blue"</span>)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"true"</span>)   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"10"</span>)     <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>3.当判断对象的时候，先执行valueOf()，再执行toString(),再测试返回值。</p>
<h4 id="3-4-5-4-数值转化"><a href="#3-4-5-4-数值转化" class="headerlink" title="3.4.5.4 数值转化"></a>3.4.5.4 数值转化</h4><p>非数值转化数值方法：<br><code>Number()</code>    //将<strong>任何类型</strong>转化为数值  <em>+的操作符操作与它相同</em><br><code>parseInt()</code>  //将<strong>字符串</strong>转化为数值–<strong>整数</strong>忽略小数点后<br><code>parseFloat()</code>//将<strong>字符串</strong>转化为数值–<strong>浮点数</strong>忽略第二个小数点后</p>
<p>Number():<br>Number(null) //0<br>Number(undefined) //NaN<br>Number(‘hello world’)  //NaN<br>Number(‘’)    //0<br>Number(‘0011’)  //11<br>Number(‘1.1’)  //1.1<br>Number(true)    //1</p>
<p>parseInt()   //0  字符串为空的时候为0<br>1.忽略前导零<br>2.自动转化为十进制<br>3.如果是对象，先调用<code>valueoOf()</code>,如果为NaN则调用<code>toString()</code>,然后再转化返回的字符串<br>4.转化为整数，忽略小数点以后的数字，因小数点以后不是有效的数字字符<br>5.可以识别十六进制和八进制，首位0x为十六进制，0数字为八进制</p>
<p>parseInt(‘’)   //NaN<br>parseInt(22.5)  //22<br>parseInt(‘0xA’)  //10   十六进制<br>parseInt(‘070’)  //56  ES3-八进制<br>parseInt(‘070’)  //70  ES5-十进制-忽略前导零<br>因为上边这种情况，所以引入第二个参数<br>parseInt(‘070’,10)   //这样就可以确定是几进制了</p>
<p>parseFloat()<br>1.忽略第二个小数点后的值<br>2.忽略前导零<br>3.只解析十进制–十六进制被转化为0</p>
<p>parseFloat(0xA);   //0<br>parseFloat(22.3.4);  //22.3<br>parseFloat(07);   //7<br>parseFloat(3.1e2);   //310</p>
<h3 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6 String类型"></a>3.4.6 String类型</h3><p>“”和’’效果是一模一样的<br>转义序列  \n表示换行—-P33<br>length可以返回字符的数目，如果字符串中包含双字节字符，length可能不会精确的返回字符串中的字符数目<br>字符串一经创建就不能改变，要改变某个变量保存的字符串，首先要销毁，再扩充该变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">'hel'</span>;</span><br><span class="line"><span class="keyword">var</span> lang = lang + <span class="string">'low'</span>;   <span class="comment">//前边的lang会被销毁</span></span><br></pre></td></tr></table></figure></p>
<p>老浏览器–先扩充一个6字节的内存，然后分别存入hel和low，然后销毁之前这两个值（慢的原因）<br>新浏览器–直接在lang内进行扩充3个字节</p>
<h4 id="3-4-6-3-转换为字符串"><a href="#3-4-6-3-转换为字符串" class="headerlink" title="3.4.6.3 转换为字符串"></a>3.4.6.3 转换为字符串</h4><p><code>toString()</code><br>每个字符串都有这个方法，但是<strong>null和undefined没有这个方法</strong><br>toString(8)     //<strong>参数</strong>以八进制输出<br>例：num.toString(8)</p>
<p><code>String()</code>   //不知道是否是null和undefined的时候可以用这个方法<br>1.如果值有toString方法，则调用toString<br>2.如果值为null，则返回”null”<br>3.如果职位undefined，则返回”underfined”<br>例：String(num)</p>
<h3 id="3-4-7-Object类型"><a href="#3-4-7-Object类型" class="headerlink" title="3.4.7 Object类型"></a>3.4.7 Object类型</h3><p>var o = new Object();  //创建一个新对象<br><strong>如果不传参数可以不要Object后边的(),但不推荐</strong><br>每个实例都有下列属性的方法<br><code>constructor</code>：保存用于创建当前对象的函数，就是new Object中的Object<br><code>hasOwnProperty(propertyName)</code>:检查属性在当前实例中，而不再原型中<br>o.hasOwnProperty(“name”)   //name是o实例对象上的属性<br><code>isPrototypeOf(object)</code>:检查是否为对象的原型<br><code>propertyIsEnumerable(propertyName)</code>: 检查给定的属性是否能够使用for-in语句来枚举，参数以字符串形式指定。<br><code>toLocaleString()</code>:返回对象的字符串表示，该字符串与执行环境的地区对应。<br><code>toString</code>：返回对象的字符串形式<br><code>valueOf()</code>: 返回对象的字符串、数值或布尔值表示，通常与toString返回值<strong>相同</strong></p>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h2><p>操作符通常会调用对象的valueOf()和(或)toString()方法，以便取得可以操作的值。</p>
<h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h3><p>只能操作一个值得操作符叫一元操作符。</p>
<h4 id="3-5-1-1-递增和递减"><a href="#3-5-1-1-递增和递减" class="headerlink" title="3.5.1.1 递增和递减"></a>3.5.1.1 递增和递减</h4><p>++  –   分为前置和后置<br>不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象<br>1.包含有效数字字符的字符串时，<strong>先将其转换为数字值</strong>，再执行加减1的操作<br>2.不包含有效数字字符的字符串，将变量值设为<strong>NaN</strong><br>3.布尔值会转化为0/1然后再进行++–操作<br>4.浮点值可以++–操作<br>5.对象先调用valueOf(),如果结果为NaN，则调用toString();</p>
<h4 id="3-5-1-2-一元-和-操作符"><a href="#3-5-1-2-一元-和-操作符" class="headerlink" title="3.5.1.2 一元+和-操作符"></a>3.5.1.2 一元+和-操作符</h4><p>非数值型的一元操作符会想Number()转换函数一样对这个值执行转换。<br>var s = +’hello’  //NaN    翻看Number()</p>
<h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h3><p>ES中所有数值都以IEEE-754B64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换为32位的整数，然后执行操作，最后再将结果转换回64位。<br>有符号的整数，32位中前31位用于表示整数的值。第32位用于表示数值的符号。<strong>0表示正，1表示负</strong><br><em>更新中···</em></p>
<h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h3><p>与(AND)或(OR)非(NOT)</p>
<h4 id="3-5-3-1-逻辑非"><a href="#3-5-3-1-逻辑非" class="headerlink" title="3.5.3.1 逻辑非 !"></a>3.5.3.1 逻辑非 <code>!</code></h4><p>先将操作数转换为布尔值，然后再取反–<em>参照Boolean</em><br>1.如果操作数是一个对象，返回false<br>2.如果操作数是一个空字符串，返回true<br>3.如果操作数是一个非空字符串，返回false<br>4.如果操作数是数值0，返回true<br>5.如果操作数是任意非0的值（包括Infinity）,返回false<br>6.如果操作数是null/NaN/undefined，返回true<br><em>使用两个!!就相当于Boolean()</em></p>
<h4 id="3-5-3-2-逻辑与-amp-amp"><a href="#3-5-3-2-逻辑与-amp-amp" class="headerlink" title="3.5.3.2 逻辑与 &amp;&amp;"></a>3.5.3.2 逻辑与 <code>&amp;&amp;</code></h4><p>当有一个操作数不是布尔值的时候<br>短路操作，第一个为false就不往下进行了<br>1.第一个操作数是对象，返回第二个操作数<br>2.第二个操作数是对象，只有在第一个值为true的时候，才返回这个对象<br>3.两个操作数都是对象，返回第二个操作数<br>4.如果有一个操作数是null/NaN/undefined，则返回null/NaN/undefined<br><strong>两个都为false时也执行</strong><br>按正常理解就行</p>
<h4 id="3-5-3-3-逻辑或"><a href="#3-5-3-3-逻辑或" class="headerlink" title="3.5.3.3 逻辑或 ||"></a>3.5.3.3 逻辑或 <code>||</code></h4><p>也是短路操作，第一个为true的话，就不往下进行了<br>1.第一个操作数是对象，则返回第一个操作数<br>2.第一个操作数的求值结果为false，则返回第二个操作数<br>3.如果两个操作数都是对象，则返回第一个操作数<br>4.两个操作数都是null/NaN/undefined则返回null/NaN/undefined</p>
<h3 id="3-5-4-乘法操作符"><a href="#3-5-4-乘法操作符" class="headerlink" title="3.5.4 乘法操作符"></a>3.5.4 乘法操作符</h3><p>乘法、除法、求模<br>非数值的情况下会执行自动类型转换<code>Number()</code>转换</p>
<h4 id="3-5-4-1-乘法"><a href="#3-5-4-1-乘法" class="headerlink" title="3.5.4.1 乘法"></a>3.5.4.1 乘法</h4><p>1.一个操作数为NaN，结果为NaN<br>2.Infinity与0相乘，结果NaN<br>3.Infinity与非0相乘，结果为Infinity<br>4.Infinity和Infinity相乘结果是Infinity</p>
<h4 id="3-5-4-2-除法"><a href="#3-5-4-2-除法" class="headerlink" title="3.5.4.2 除法"></a>3.5.4.2 除法</h4><p>1.零被零除，结果是NaN<br>2.非零的有限数被0除，结果是Infinity<br>3.Infinity和Infinity相除结果是NaN</p>
<h4 id="3-5-4-3-求模（余数-）"><a href="#3-5-4-3-求模（余数-）" class="headerlink" title="3.5.4.3 求模（余数%）"></a>3.5.4.3 求模（余数%）</h4><p>1.被除数为0的时候，结果为0</p>
<h3 id="3-5-5-加性操作符"><a href="#3-5-5-加性操作符" class="headerlink" title="3.5.5 加性操作符"></a>3.5.5 加性操作符</h3><h4 id="3-5-5-1-加法"><a href="#3-5-5-1-加法" class="headerlink" title="3.5.5.1 加法"></a>3.5.5.1 加法</h4><p>1.如果一个操作符是NaN,结果是NaN<br>2.Infinity加-Infinity，结果为NaN<br>3.如果有一个是字符串，则<strong>执行字符串拼接操作</strong></p>
<h4 id="3-5-5-2-减法"><a href="#3-5-5-2-减法" class="headerlink" title="3.5.5.2 减法"></a>3.5.5.2 减法</h4><p>1.如果有一个为NaN,则结果为NaN<br>2.Infinity减Infinity，结果为NaN<br>3.-Infinity减-Infinity，结果为NaN<br>4.Infinity减-Infinity，结果为Infinity<br>5.-Infinity减Infinity，结果为-Infinity</p>
<h3 id="3-5-6-关系操作符"><a href="#3-5-6-关系操作符" class="headerlink" title="3.5.6 关系操作符"></a>3.5.6 关系操作符</h3><p>&lt; &gt; &lt;= &gt;=  //返回布尔值<br>1.两个都是字符串的话，比较<strong>字符编码值</strong><br>2.布尔值将其转化为数值后，再比较</p>
<h3 id="3-5-7-相等操作符"><a href="#3-5-7-相等操作符" class="headerlink" title="3.5.7 相等操作符"></a>3.5.7 相等操作符</h3><p>== 和 !=     //先<strong>转换</strong>为相似的类型再比较<br>1.如果一个操作符为NaN,相等操作符返回false，不相等操作符返回true<br>2.如果两个操作符为NaN,相等操作符返回false，不相等操作符返回true<br>null == undefined  //true</p>
<p>=== 和!==    //仅比较<br>‘55’ === 55  //false</p>
<h3 id="3-5-8-条件操作符-三元运算符"><a href="#3-5-8-条件操作符-三元运算符" class="headerlink" title="3.5.8 条件操作符-三元运算符"></a>3.5.8 条件操作符-三元运算符</h3><p>variable = boolean_expression ? true_value : false_value<br>判断boolean_expression，正确执行true_value，错误执行false_value</p>
<h3 id="3-5-9-赋值操作符"><a href="#3-5-9-赋值操作符" class="headerlink" title="3.5.9 赋值操作符"></a>3.5.9 赋值操作符</h3><p>=   //赋值<br>复合赋值<br>*=<br>+=<br>%=<br>&lt;&lt;=    //左移赋值<br>=&gt;&gt;    //右移赋值</p>
<h3 id="3-5-10-逗号操作符"><a href="#3-5-10-逗号操作符" class="headerlink" title="3.5.10 逗号操作符"></a>3.5.10 逗号操作符</h3><p>在一个语句中执行多个操作<br>var num1 = 1,num2 =2,num3 = 3;<br>赋值时候，只返回<strong>最后一个</strong>表达式<br>var num = (5,1,4,8)   //num的值为8</p>
<h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h2><h3 id="3-6-5"><a href="#3-6-5" class="headerlink" title="3.6.5"></a>3.6.5</h3><p>使用for-in循环之前，先<strong>检查</strong>确认该对象的值<strong>不是null或undefined</strong><br><strong>判断undefined</strong> 用typeof(x) == “undefined”<br><strong>判断null</strong>   用 x == null</p>
<h3 id="3-6-7-break和continue语句"><a href="#3-6-7-break和continue语句" class="headerlink" title="3.6.7 break和continue语句"></a>3.6.7 break和continue语句</h3><p>break 立即跳出循环，强制继续执行循环后面的语句<br>continue 立即跳出循环，从循环顶部继续执行</p>
<h3 id="3-6-9-switch语句"><a href="#3-6-9-switch语句" class="headerlink" title="3.6.9 switch语句"></a>3.6.9 switch语句</h3><p>switch(i){<br>    case 20:<br>        alert(‘25’);<br>        break;<br>    case 22:<br>    case 23:<br>        alert(‘22或23’);<br>        break;<br>    default:<br>        alert(‘没有相应的值’);<br>}<br><strong>i和case的值不一定是数值，可以是任何数据类型</strong><br>case 是用来判断i的</p>
<h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h2><p>任何函数在任何时候都可以通过<code>return</code>语句后跟要返回的值来实现返回值<br>位于<code>return</code>语句之后的任何代码都永远不会被执行<br><code>return</code>语句可以不带任何返回值。这种情况下，函数在停止执行后将返回<code>undefined</code></p>
<h3 id="3-7-1-理解参数"><a href="#3-7-1-理解参数" class="headerlink" title="3.7.1 理解参数"></a>3.7.1 理解参数</h3><p>参数只提供便利，但不是必须的。<br>参数用arguments表示，可以通过arguments[]来取值<br>arguments[0]和传入的第一个参数所占用的<strong>内存空间是不同</strong>的，但他们的<strong>值会同步</strong><br>没有传入参数的命名参数会被自动设置为<code>undefined</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num1,num2</span>)</span>&#123;&#125;</span><br><span class="line">foo(<span class="number">10</span>)      <span class="comment">//此时num2就是undefined</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-8-2-没有重载"><a href="#3-8-2-没有重载" class="headerlink" title="3.8.2 没有重载"></a>3.8.2 没有重载</h3><p>重载的意思就是可以存在两个相同名字的函数，但是js并不具备重载能力<br>出现两个相同名字的函数时，该名字只<strong>属于后定义</strong>的函数。</p>
<h1 id="4-变量、作用域和内存问题"><a href="#4-变量、作用域和内存问题" class="headerlink" title="4. 变量、作用域和内存问题"></a>4. 变量、作用域和内存问题</h1><h2 id="4-1-基本类型和引用类型"><a href="#4-1-基本类型和引用类型" class="headerlink" title="4.1 基本类型和引用类型"></a>4.1 基本类型和引用类型</h2><p>基本类型和引用类型在3.4数据类型的时候已经说过，不再赘述<br>基本类型指的是简单的数据段<br>引用类型指的是那些可能由多个值构成的对象<br>引用类型的值保存在内存中的对象。javascript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。<br>在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p>
<h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1 动态属性"></a>4.1.1 动态属性</h3><p>不能给基本类型的值添加属性，尽管这样做不会导致任何错误。</p>
<h3 id="4-1-2-复制变量值"><a href="#4-1-2-复制变量值" class="headerlink" title="4.1.2 复制变量值"></a>4.1.2 复制变量值</h3><p>从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。<br>var num1 = 5;<br>var num2 = num1;</p>
<p>num2的值是5，但是这个5只是num1的一个副本，和num1的5是完全独立的，不会互相影响。<br>但是如果赋值的是一个引用类型，那么这个副本就是一个指针，一改变都改变。</p>
<h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h3><p>函数的参数都是按值传递的，引用类型的参数也是按值传递的。<br>如果传递的参数是引用类型，那在函数内部参数值改变，那外边的值也就改变了，就乱套了！<br><strong>下边例子很重要</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();    <span class="comment">//重点在这里，参数，参数，参数被重写在这里是一个局部变量(如果不是重写参数就不一样了)，是局部变量，所以在执行完毕的时候，这个局部变量就会自动销毁，不影响外边的obj</span></span><br><span class="line">    obj.name = <span class="string">'Greg'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name);    <span class="comment">//'Nicholas'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-4-检查数据类型"><a href="#4-1-4-检查数据类型" class="headerlink" title="4.1.4 检查数据类型"></a>4.1.4 检查数据类型</h3><p>typeof返回的字符串有<code>undefined</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>object</code>、<code>function</code><br>typeof(null)   //object,因为被作为一个空对象使用<br>typeof(正则表达式)   //function  因为内部实现[[Call]]方法的对象都返回function</p>
<p>instanceof判断引用类型，返回值为<code>true</code>和<code>false</code><br>person instanceof Object  //判断是不是对象<br>Array<br>RegExp<br>Function</p>
<h2 id="4-2-执行环境及作用域"><a href="#4-2-执行环境及作用域" class="headerlink" title="4.2 执行环境及作用域"></a>4.2 执行环境及作用域</h2><p>所有的全局变量和函数都是作为window对象的属性和方法创建的！<br>全局变量只有在关闭网页或浏览器的时候才会销毁。<br>局部变量在执行完毕后自动销毁<br>函数执行的时候，就会被推入一个环境栈内，执行完成后，栈就将其环境弹出<br>环境执行时，会创建一个作用域链，最开始只包含一个变量，即<code>arguments</code>对象，这个对象在全局环境中是不存在的<br>最外层为全局变量<br>标识符解析是沿着作用域链一级一级的搜索标识符的过程，从前端开始向后回溯查找，找到为止。<br>外部环境不能访问内部环境中的任何变量和函数</p>
<h3 id="4-2-1-延长作用域链"><a href="#4-2-1-延长作用域链" class="headerlink" title="4.2.1 延长作用域链"></a>4.2.1 延长作用域链</h3><p>try-catch语句的catch块<br>with语句<br>这两种语句会改变作用域链，不推荐使用</p>
<h3 id="4-2-2-没有块级作用域"><a href="#4-2-2-没有块级作用域" class="headerlink" title="4.2.2 没有块级作用域"></a>4.2.2 没有块级作用域</h3><p>if语句和for语句都没有作用域<br>所以在它们内部定义的变量，一直存在于它们外部的执行环境中</p>
<h4 id="4-2-2-1-声明变量"><a href="#4-2-2-1-声明变量" class="headerlink" title="4.2.2.1 声明变量"></a>4.2.2.1 声明变量</h4><p>使用var声明的变量会自动被添加到最接近的环境中。<br>但是如果没有使用var声明，则被添加到全局环境。</p>
<h3 id="4-2-2-2-查询标识符"><a href="#4-2-2-2-查询标识符" class="headerlink" title="4.2.2.2 查询标识符"></a>4.2.2.2 查询标识符</h3><p>从最前端开始找一直追溯到全局环境<br>访问局部变量要比访问全局变量跟快，因为不用向上搜索作用域链</p>
<h2 id="4-3垃圾收集"><a href="#4-3垃圾收集" class="headerlink" title="4.3垃圾收集"></a>4.3垃圾收集</h2><h3 id="4-3-1-标记清除"><a href="#4-3-1-标记清除" class="headerlink" title="4.3.1 标记清除"></a>4.3.1 标记清除</h3><p>当变量进入环境的时候标记为”进入环境”，当离开环境时，标记为”离开环境”<br>垃圾收集器在运行的时候会给存储在内存中的<strong>所有变量</strong>都加上标记。<br>然后它会去掉<strong>环境中的变量</strong>，以及<strong>被环境中的变量引用的变量</strong>的标记。<br>再此之后所有被加上标记的和已经含有标记的所有变量将被视为<strong>准备删除</strong>的变量。</p>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a>4.3.2 引用计数</h3><p>被引用一次标记为+1，替换为别的变量的时候-1<br>闭包永远不为0，所以会常驻内存</p>
<p>不使用的时候，最好手工断开DOM和原生javascript之间的联系，用<code>null</code><br>当垃圾收集器<strong>下次</strong>运行时，会删除这些值并回收内存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"hehe"</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject</span><br><span class="line"></span><br><span class="line"><span class="comment">//上边两句循环引用，无法回收，下边进行清除</span></span><br><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-3-性能问题"><a href="#4-3-3-性能问题" class="headerlink" title="4.3.3 性能问题"></a>4.3.3 性能问题</h3><p>256个变量、4096个对象或数组或者64KB的字符串打到这个临界值，启动垃圾收集器<br>IE 在回收内存不到15%的时候，变量、字面量或数组的临界值就会加倍。<br>IE 在回收内存超过85%的时候，则将各种临界值重置回默认值</p>
<p>强制执行垃圾收集器<br>IE: window.CollectGarbage()<br>Opera7: window.opera.collect()</p>
<h3 id="4-3-4-管理内存"><a href="#4-3-4-管理内存" class="headerlink" title="4.3.4 管理内存"></a>4.3.4 管理内存</h3><p>通常分配给Web浏览器的可用内存数要比分配给桌面应用程序的少，这样主要是出于安全方面考虑，防止js网页耗尽系统内存导致崩溃。<br>内存限制不仅会影响给变量分配内存，还影响调用栈以及在一个线程中能够同时执行的语句数量。</p>
<p>优化：一点数据不再有用，最好通过将其值设置为null来释放其引用–解除引用<br>一般全局变量不使用他的时候，手工接触引用。<br>解除一个值的引用并不意味着自动回收该值所占用的内存。<br>接触引用的真正作用是让值<strong>脱离执行环境</strong>，以便垃圾收集器<strong>下次</strong>运行时将其回收。</p>
<h1 id="5-引用类型"><a href="#5-引用类型" class="headerlink" title="5 引用类型"></a>5 引用类型</h1><p>引用类型的值(对象)是引用类型的一个<strong>实例</strong>，常被成为类。<br>JS是面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构</p>
<p>新对象是使用<code>new</code>操作符后跟一个构造函数来创建的，构造函数本身就是一个函数。</p>
<h2 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h2><p>创建Object实例有<strong>两种方法</strong><br>1.var person = new Object();      //构造函数<br>2.var person = {};                //对象字面量<br><em>通过对象字面量定义的对象，不会调用Object构造函数</em><br><strong>对象字面量是向函数传递大量可选参数的首选方式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">displayInfo(</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">'pengzhang'</span>,</span><br><span class="line">        age:<span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>访问对象属性，两种方法：<br>1.点<br>2.方括号  –可以通过变量访问属性</p>
<h2 id="5-2-Array-类型"><a href="#5-2-Array-类型" class="headerlink" title="5.2 Array 类型"></a>5.2 Array 类型</h2><p>创建数组的基本方式有<strong>两种方法</strong><br>1.构造函数<br>var colors = new Array();<br>var colors = new Array(3);    //数组长度<br>var colors = new Array(“red”,”green”);   //数组内容<br><em>可以省略new，结果是一样的 var colors = new Array(3)</em></p>
<p>2.数组字面量表示法<br>var colors = [];<br>var colors = [1,2,]     //IE8及之前认为有3项，1，2，undefined。之后的浏览器都认为有两项<br>var colors = [,,,,,]    //5或者6个数组,都是undefined</p>
<p><em>通过对象字面量定义的数组，不会调用Array构造函数</em></p>
<p>移除数组可以通过<strong>减少数组长度</strong>来实现<br>在位置99插入一个值得话，数组的长度就是99了，中间项用undefined来代替！</p>
<h3 id="5-2-1-检查数组"><a href="#5-2-1-检查数组" class="headerlink" title="5.2.1 检查数组"></a>5.2.1 检查数组</h3><p>因为instanceof判断数组的条件是，假定只有一个全局执行环境，如果网页包含多个框架(有多个全局环境)，<br>从而存在两个以上不同版本的Array构造函数。<br>ES5增加了<code>Array.isArray()</code>方法，最终确定某个值到底是不是数组，而不用管他是在哪个全局执行环境中创建的。<br>更高级的判断的方法可以参考P22.1.1</p>
<h3 id="5-2-2-转换方法"><a href="#5-2-2-转换方法" class="headerlink" title="5.2.2 转换方法"></a>5.2.2 转换方法</h3><p>对象的属性上边有说，下边利用这些属性来进行转换<br>var colors = [‘red’,’blue’,’green’];<br>colors.toString();    //red,blue,green    转化为字符串<br>colors.valueOf();     //red,blue,green    转化为字符串<br>alert(colors)        //alert这个方法接受必须字符串参数，所以数组会先转化为字符串在传入，所以打印的也是red,blue,green<br><strong>在转化的默认情况都是用,来进行分割的，其实是内部调用了join()方法，可以修改分割符</strong><br>colors.toString().join(“||”)    //结果就是   red||blue||green</p>
<p><code>toLocaleString()</code>方法和上边两种不同的地方是，这次是每一项都进行toLocaleString()而不是toString()，这个也可以用来转化为本地时间用。</p>
<h3 id="5-2-3-栈方法"><a href="#5-2-3-栈方法" class="headerlink" title="5.2.3 栈方法"></a>5.2.3 栈方法</h3><p>栈是一种LIFO的数据结构(后进先出)，也就是最新添加的项最早被移除。<br>栈中项的推入和弹出都发生在栈的顶部。<br>可以通过<code>push()</code> <code>pop()</code> 方法进行操作</p>
<h3 id="5-2-4-队列的方法"><a href="#5-2-4-队列的方法" class="headerlink" title="5.2.4 队列的方法"></a>5.2.4 队列的方法</h3><p>队列的访问规则是FIFO(先进先出)<br>实现这一操作的方法<code>push()</code> <code>shift()</code></p>
<p>ES还为数组提供了一个unshift()方法。在最<strong>前端添加</strong>任意个项，返回长度</p>
<h3 id="5-2-5-重排序方法"><a href="#5-2-5-重排序方法" class="headerlink" title="5.2.5 重排序方法"></a>5.2.5 重排序方法</h3><p>reverse()按降序排列<br>sort()按升序排列   <strong>转化为字符串后进行比较，比较的是字符串，因为比较的字符串，所以比较的就是字符编码，所以就会不准确，10就会位于5的前面</strong><br>所以推荐用比较函数来<strong>替代</strong><code>sort()</code><br>下边这个表示<strong>升序</strong> 降序在判断时候取反就对了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果比较的数值类型的话，可以用下边这个比较函数(升序)降序是b-a<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>调用方法</strong><br>values.sort(compare)   //作为参数不用带()</p>
<h3 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a>5.2.6 操作方法</h3><p><code>concat()</code> 合并数组。先创建当前数组一个<strong>副本</strong>，然后将接收的参数添加到这个副本的末尾。<br>var colors = [‘red’];<br>colors.concat(‘green’,[‘blue’,’black’])</p>
<p><code>slice()</code>基于当前组中的一个或多个项创建一个新数组。<br>可接受一个或者两个参数，即要返回的<strong>起始和结束的位置</strong><br>slice()不会影响原始数组</p>
<p><code>splice</code>可以实现<code>插入``删除``替换</code><br>删除：两个参数<br>第一个参数为第一项的<strong>位置</strong>，第二个参数为删除的<strong>项数</strong><br>插入：两个参数(第二个参数为0)+插入项<br>splice(2,0,”red”)<br>替换：两个参数+替换项<br>splice(2,1,”red”)</p>
<h3 id="5-2-7-位置方法"><a href="#5-2-7-位置方法" class="headerlink" title="5.2.7 位置方法"></a>5.2.7 位置方法</h3><p>ES5添加了<code>indexOf()</code>方法和<code>lastIndexOf()</code>方法<br>从开始向后查找和从后向前查找<br>两个参数：要查找的项+查找的起点位置<br>没有找到的话返回<code>-1</code><br><strong>只返回第一个找到的位置</strong><br>var numbers = [1,2,3,4]<br>numbers.indexOf(4)  //3  返回的是位置</p>
<h3 id="5-2-8-迭代方法"><a href="#5-2-8-迭代方法" class="headerlink" title="5.2.8 迭代方法"></a>5.2.8 迭代方法</h3><p>ES5定义了5个迭代方法P96<br><code>some()</code>有一项返回true，就返回<strong>true</strong><br><code>every()</code>每一项都返回true，则返回<strong>true</strong>,一项不是就返回<strong>false</strong><br><code>filter()</code>所有返回true的<strong>数组</strong><br><code>forEach()</code>对每一项进行操作<br><code>map()</code>对每一项进行操作，返回<strong>数组</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//every</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item&gt;<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">alert(everyResutl)    <span class="comment">//false  因为不是所有的项都大于2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//filter</span></span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (itme&gt;<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">alert(filterResult)   <span class="comment">//[3,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item*<span class="number">2</span>*)</span><br><span class="line">&#125;)</span><br><span class="line">alert(mapRsult)    <span class="comment">//[2,4,6,8,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach</span></span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//执行某些操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-9-归并方法"><a href="#5-2-9-归并方法" class="headerlink" title="5.2.9 归并方法"></a>5.2.9 归并方法</h3><p>ES5新增了两种方法 <code>reduce()</code>和<code>reduceRight()</code><br>他们都是迭代数组项，然后构建一个最终返回值<br>reduce() 从数组第一项开始<br>reduceRight() 从数组最后一项开始<br>接收两个参数：调用的函数+归并初始值<br>传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引、数组对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev+cur</span><br><span class="line">&#125;)</span><br><span class="line">alert(sum);    <span class="comment">//15</span></span><br></pre></td></tr></table></figure></p>
<p>第一次prev是1，cur是2<br>第二次prev是3，cur是3<br>第三次prev是6，cur是4<br>第四次prev是10，cur是5<br>第五次prev是15，返回15</p>
<h2 id="5-3-Date类型"><a href="#5-3-Date类型" class="headerlink" title="5.3 Date类型"></a>5.3 Date类型</h2><p>使用自UTC1970年1月1日午夜开始<br>创建一个日期对象<br>var now = new Date();<br>不传参数话：自动获得当前日期和时间。<br>传入参数：获得1970到传入参数时间的毫秒数<br>ES提供两个方法简化计算：<code>Date.parse()</code> <code>Date.UTC()</code><br>传入Date.parse()的字符串不能表示日期，则返回<code>NaN</code><br>直接传递给Date构造函数，后台也是调用的这个<br>var someDate = new Date(Date.parse(“May 25,2004”));<br>var someDate = new Date(“May 25,2004”);<br>上边两个相等的<br>Date.UTC()对象表示的是GMT时间<br>ES5添加了<code>Date.now()</code>方法：返回调用这个方法时的时间毫秒数，一般用于测试<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">doSomething();</span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now();</span><br><span class="line">result = stop-star;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-3-1-继承的方法"><a href="#5-3-1-继承的方法" class="headerlink" title="5.3.1 继承的方法"></a>5.3.1 继承的方法</h3><p>Date重写了toLocalString、toString、valueOf()方法<br>toLocalString会按照与浏览器设置的地区相适应的格式返回日期和时间，包含AM\PM，但不会包含时区信息<br>toString返回带有时区信息的日期和时间，一般以军用时间表示。</p>
<p>valueOf()方法，根本不返回字符串，而是返回日期的<strong>毫秒</strong>。<br>7月1日小于7月2日 返回true</p>
<h3 id="5-3-3-组件方法"><a href="#5-3-3-组件方法" class="headerlink" title="5.3.3 组件方法"></a>5.3.3 组件方法</h3><p>getFullYear()<br>setFullYear()<br>getMonth()-月<br>getDate() -日<br>getDay()  -星期<br>getHours()<br>getMinutes()<br>getSeconds()<br>getMilliseconds()</p>
<h2 id="5-4-RegExp-类型"><a href="#5-4-RegExp-类型" class="headerlink" title="5.4 RegExp 类型"></a>5.4 RegExp 类型</h2><p>g 全局-所有字符串，而非找到第一个就停止<br>i 不区分大小写<br>m 多行模式</p>
<p>更新中···</p>
<h2 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a>5.5 Function类型</h2><p>函数声明：<br>function foo(){}<br>函数表达式<br>var foo = function(){}<br>构造函数<br>var foo = new Function(‘num1’,’num2’,’return num1+num2’)<br><strong>最后一个参数为函数体，函数体，函数体。前边的为参数</strong><br>从技术上讲构造函数是函数表达式，不推荐这么写，因为这样会执行两次（第一次是解析常规ES代码，第二次是解析传入构造函数中的字符串）从而影响性能<br><strong>一个函数可能会有多个名字–因为操作的是指针，而非对象。</strong></p>
<h3 id="5-5-1-没有重载"><a href="#5-5-1-没有重载" class="headerlink" title="5.5.1 没有重载"></a>5.5.1 没有重载</h3><p>后命名的函数覆盖之前的同名函数，因为命名的是指针，指针位置改变了，所以函数体也就变了</p>
<h3 id="5-5-2-函数声明与函数表达式"><a href="#5-5-2-函数声明与函数表达式" class="headerlink" title="5.5.2 函数声明与函数表达式"></a>5.5.2 函数声明与函数表达式</h3><p>解析器会<strong>先读取函数声明</strong><br>函数声明，在执行任何代码之前可用，解析器会将其放在源代码树顶部。<br>函数表达式，只有在调用的时候才可用。</p>
<h3 id="5-5-3-作为值得函数"><a href="#5-5-3-作为值得函数" class="headerlink" title="5.5.3 作为值得函数"></a>5.5.3 作为值得函数</h3><p>ES中的函数名本身就是变量，所以函数可以作为值来使用。</p>
<h3 id="5-5-4-函数的内部属性"><a href="#5-5-4-函数的内部属性" class="headerlink" title="5.5.4 函数的内部属性"></a>5.5.4 函数的内部属性</h3><p>函数内部有两个特殊的<code>对象</code>：<code>arguments</code> 和 <code>this</code><br><code>arguments</code>这个属性还有一个名叫<code>callee</code>的属性，该属性是一个指针，指向用友这个arguments对象的函数。<br><code>this</code>引用的是函数据以执行的环境对象。全局对象的时候引用的是windows<br><code>caller</code>这个属性中保存着调用当前函数的函数的引用。如果是全局作用域中调用当前函数，它的值为null。<br>为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息。<br>严格模式下：<br>arguments.callee会导致错误。<br>arguments.caller也会导致错误。<br>不能为arguments.caller属性赋值，否则会导致错误。<br>非严格模式：<br>arguments.caller这个属性始终是undefined。这么定义主要为了区分arguments.caller和函数本身的caller属性</p>
<h3 id="5-5-5函数的属性和方法"><a href="#5-5-5函数的属性和方法" class="headerlink" title="5.5.5函数的属性和方法"></a>5.5.5函数的属性和方法</h3><p><code>prototype</code>保存所有实例方法的真正所在。例如toString和valueOf实际上都保存在prototype。<br>ES5中prototype属性不可以枚举的，因此使用<code>for-in</code>无法发现<br>每个函数都含有两个非继承而来的的方法<code>apply()``call()</code>.<br>这两个值实际上等于设置函数体·<code>this</code>对象的值<br><code>applay()</code>两个参数分别是，在其中运行函数的作用域+另一个是参数数组(可以使Array的实例，也可以是arguments对象)。<br><code>call()</code>区别仅在接收参数方式不同。这个传递给函数的参数，必须逐个列出。<br>其实这两个属性最大的作用是：扩充函数赖以运行的作用域。<strong>通常就是继承的用法</strong><br>ES5还定义了<code>bind()</code>方法。这个方法会创建一个函数的实例，其中this值会被绑定到传给bind()函数的值。</p>
<h2 id="5-6基本包装类型"><a href="#5-6基本包装类型" class="headerlink" title="5.6基本包装类型"></a>5.6基本包装类型</h2><p>为了便于操作基本类型值，ES提供了3个特殊的引用类型：Boolean、Number、String.<br>他们具有引用类型的特性，同时也具有与各自的基本类型相应的特殊行为。<br>每读取一个基本类型的时候，后台都会创建一个对应的基本包装类型的对象。<br>例如： var s2 = s1.substring(2);<br>因为基本类型<strong>不是对象</strong>，所以不该有方法的，但是确实有，下边是后台自动完成的处理。<br>1.创建String类型的一个实例<br>2.在实例上调用指定的方法<br>3.销毁这个实例<br>上边三个步骤都适用于Number和Boolean。</p>
<p>引用类型和包装类型的主要区别就是对象的生存期。<br>引用类型一直存在于内存中。<br>包装对象值存在于一行代码的执行瞬间，然后立即销毁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"text"</span></span><br><span class="line">s1.color = <span class="string">"red"</span></span><br><span class="line">alert(s1.red)   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>基本包装类型的实例调用<code>typeof</code>返回object，而且所有基本包装类型对象都会被转换为布尔值<code>true</code><br><strong>用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">'25'</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value);   <span class="comment">//转型函数    保存的是数值25</span></span><br><span class="line">alert(<span class="keyword">typeof</span> number)    <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value);  <span class="comment">//构造函数    保存的是实例对象</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj)       <span class="comment">//object</span></span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">Number</span>)   <span class="comment">//true</span></span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><em>不建议显式的创建基本包装类型的对象</em></p>
<h3 id="5-6-1-Boolean类型"><a href="#5-6-1-Boolean类型" class="headerlink" title="5.6.1 Boolean类型"></a>5.6.1 Boolean类型</h3><p>创建Boolean对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> booleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<p>Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false<br>重写了toString()方法，返回字符串”true”或”false”<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);       <span class="comment">//将false重写了，相当于true</span></span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result)                              <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><em>布尔值与Blooean对象之间区别很重要，建议永远不要使用Boolean对象</em></p>
<h3 id="5-6-2-Number类型"><a href="#5-6-2-Number类型" class="headerlink" title="5.6.2 Number类型"></a>5.6.2 Number类型</h3><p>也重写了vauleOf()和toString()和toLocalString方法<br>valueOf返回的是基本类型的数值<br>toString和toLocalString返回的是字符串形式的数值<br>toString传递一个表示基本的参数，告诉是几进制数值的字符串形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString(<span class="number">2</span>))   <span class="comment">//1010  转换为二进制</span></span><br></pre></td></tr></table></figure></p>
<p>将数值转化为字符串的方法<br><code>toFixed</code>按指定的小数位返回数值的字符串形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.005</span>;</span><br><span class="line">alert(num.toFixed(<span class="number">2</span>))   <span class="comment">//10.00  转换为二进制</span></span><br></pre></td></tr></table></figure></p>
<p><em>超过指定位数会自动舍入，不同浏览器舍入值不同</em><br><code>toExponential()</code>该方法返回科学记数法(e)。<br><code>toPrecision()</code>返回固定大小格式。接收一个参数，表示数值的所有数字位数（不好考指数部分）。这个方法<strong>兼容</strong>上边两种方法,选择上边两种最适合的方法进行使用转化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</span><br><span class="line">alert(num.toPrecision(<span class="number">1</span>))   <span class="comment">//1e+2  以一位来表示99，因为一位无法准确的表达99，所以进行舍入</span></span><br><span class="line">alert(num.toPrecision(<span class="number">2</span>))   <span class="comment">//99</span></span><br></pre></td></tr></table></figure></p>
<p><em>同样不建议使用Numer实例化对象，最最最主要的原因是在判断Number的typeof的时候会有两个不同的值</em></p>
<h3 id="5-6-3-String类型"><a href="#5-6-3-String类型" class="headerlink" title="5.6.3 String类型"></a>5.6.3 String类型</h3><p>String包装类型的创建<br>var stringObject = new String(“hello world”)<br>继承的toString、toLocalString、valueOf返回对象所表示的基本字符串值</p>
<h4 id="5-6-3-1字符方法"><a href="#5-6-3-1字符方法" class="headerlink" title="5.6.3.1字符方法"></a>5.6.3.1字符方法</h4><p><code>charAt()``charCodeAt()</code>访问字符串中特定字符的方法.<br>都接收一个参数，即基于0的字符位置。<br>charAt() 返回<strong>字符</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">'hello'</span>;</span><br><span class="line">alert(stringValue.charAt(<span class="number">1</span>));   <span class="comment">//"e"</span></span><br></pre></td></tr></table></figure></p>
<p>以上结果也可以通过stringValue[1]来获得<br>charCodeAt()是返回<strong>字符编码</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">'hello'</span>;</span><br><span class="line">alert(stringValut.charCodeAt(<span class="number">1</span>));   <span class="comment">//"101"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-6-3-2-字符串操作方法"><a href="#5-6-3-2-字符串操作方法" class="headerlink" title="5.6.3.2 字符串操作方法"></a>5.6.3.2 字符串操作方法</h4><p><code>concat()</code>  字符串拼接，实际中还是使用<code>+</code>更简便一些<br>基于子字符串创建新字符串方法，第一个参数都是指开始位置<br><code>slice()</code>   第二个参数指最后一个字符串的<strong>位置</strong><br><code>substring</code> 第二个参数指最后一个字符串的<strong>位置</strong><br><code>substr()</code>  第二个参数指最后一个字符串的<strong>个数</strong></p>
<p>以上三个数最大区别在传入<strong>负数</strong>的时候<br><code>slice()</code>将传入的负值与字符串长度相加<br><code>substr()</code>将负的第一个参数与字符串长度相加，而将负的第二个参数转换为0.<br><code>substring</code>把所有负值参数转换为0<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">'hello world'</span>  </span><br><span class="line">stringValue.slice(<span class="number">-3</span>)    <span class="comment">//rld     -3+11</span></span><br><span class="line">stringValue.substring(<span class="number">-3</span>)   <span class="comment">//hello world    0</span></span><br><span class="line">stringValue.substr(<span class="number">-3</span>)   <span class="comment">//rld     -3+11</span></span><br><span class="line">stringValue.slice(<span class="number">3</span>,<span class="number">-4</span>)   <span class="comment">//lo w    3,-3+11</span></span><br><span class="line">stringValue.substring(<span class="number">3</span>,<span class="number">-4</span>)  <span class="comment">//hel    3,0</span></span><br><span class="line">stringValue.substr(<span class="number">3</span>,<span class="number">-4</span>)     <span class="comment">//""     3,0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-6-3-3-字符串位置方法"><a href="#5-6-3-3-字符串位置方法" class="headerlink" title="5.6.3.3 字符串位置方法"></a>5.6.3.3 字符串位置方法</h4><p><code>indexOf()``lastIndexOf()</code> 查找字符串位置，只能得到<strong>第一个</strong>出现的位置<br>这两个方法可接受可选的<strong>第二个参数</strong>，表示<strong>从字符串中哪个位置开始搜索</strong><br><strong>通过增加查找位置来遍历长字符串</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"lsdjklasjdflajpjwpejkgljlsjflsajweiotu"</span></span><br><span class="line"><span class="keyword">var</span> positions = [];</span><br><span class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</span><br><span class="line"><span class="keyword">while</span>(pos&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">    positions.push(pos);</span><br><span class="line">    pos = stringValue.indeOf(<span class="string">"e"</span>,pos+<span class="number">1</span>)    <span class="comment">//向下继续找</span></span><br><span class="line">&#125;</span><br><span class="line">alert(positions);;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-6-3-4-trim-方法–删除前置及后缀所有空格"><a href="#5-6-3-4-trim-方法–删除前置及后缀所有空格" class="headerlink" title="5.6.3.4 trim()方法–删除前置及后缀所有空格"></a>5.6.3.4 trim()方法–删除前置及后缀所有空格</h4><p>ES5属性，直接调用.trim()</p>
<h4 id="5-6-3-5-字符串大小写转换"><a href="#5-6-3-5-字符串大小写转换" class="headerlink" title="5.6.3.5 字符串大小写转换"></a>5.6.3.5 字符串大小写转换</h4><p><code>toLowerCase()</code>    全小写<br><code>toLocaleLowerCase()</code>    全小写<br><code>toUpperCase()</code>     全大写<br><code>toLocaleUpperCase()</code>    全大写</p>
<h4 id="5-6-3-6-字符串的匹配方法"><a href="#5-6-3-6-字符串的匹配方法" class="headerlink" title="5.6.3.6 字符串的匹配方法"></a>5.6.3.6 字符串的匹配方法</h4><p><code>match()</code>本质上和调用RegExp的exec()方法相同。<br>只接受一个参数，要么是正则表达式，要么是RegExp对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);    <span class="comment">//得到的是一个数组</span></span><br></pre></td></tr></table></figure></p>
<p><code>search()</code>查找模式，返回字符串中第一个匹配项的<code>索引</code>，如果没有找到返回<code>-1</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cat,bat,sat'</span></span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);    <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p><code>replace()</code>第一个参数是一个字符串，第二个参数可以是一个字符串或者一个<strong>函数</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">'ond'</span>)   <span class="comment">//'cond,bond,sond,fond'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-6-3-7-localeCompare-方法"><a href="#5-6-3-7-localeCompare-方法" class="headerlink" title="5.6.3.7 localeCompare()方法"></a>5.6.3.7 localeCompare()方法</h4><p><code>localeCompare()</code>比较两个字符串，并返回下列值中的一个。<br>字符串在字母表中牌子字符串参数之前，返回-1<br>等于，返回0<br>之后，返回1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">'yellow'</span>;</span><br><span class="line">stringVaule.localCompare(<span class="string">"brick"</span>)   <span class="comment">//1   yellow在字母表中排在brick之后</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-6-3-8-fromCharCode-方法"><a href="#5-6-3-8-fromCharCode-方法" class="headerlink" title="5.6.3.8 fromCharCode()方法"></a>5.6.3.8 fromCharCode()方法</h4><p><code>fromCharCode()</code> 接收一或多个字符编码，然后将他们转化成一个字符串。与<code>charCodeAt()</code>作用相反<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">111</span>); <span class="comment">//'hello'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h2><p>由ES实现提供的、不依赖于<strong>宿主环境</strong>的对象，在程序执行<strong>之前</strong>就已经存在了。</p>
<h3 id="5-7-1-Global对象"><a href="#5-7-1-Global对象" class="headerlink" title="5.7.1 Global对象"></a>5.7.1 Global对象</h3><p>这是一个终极的”兜底儿”对象，不属于任何其他对象的属性和方法，最终都是它的属性和方法。<br>所有在全局作用域中定义的属性和函数，都是Global对象的属性。</p>
<h4 id="5-7-1-1-URL编码方法"><a href="#5-7-1-1-URL编码方法" class="headerlink" title="5.7.1.1 URL编码方法"></a>5.7.1.1 URL编码方法</h4><p><code>encodeURI()</code>对URI进行编码。不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问好和井号<br><code>encodeURIComponent()</code>会对非标准字符进行编码—-<strong>最常用</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start"</span></span><br><span class="line">alert(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line">        </span><br><span class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span></span><br><span class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></p>
<p><code>decodeURI()</code>  对encodeURI()解码<br><code>decodeURIComponent()</code> 对encodeURIComponent()解码</p>
<h4 id="5-7-1-2-eval-方法"><a href="#5-7-1-2-eval-方法" class="headerlink" title="5.7.1.2 eval()方法"></a>5.7.1.2 eval()方法</h4><p>它就像一个完整的ES<strong>解析器</strong>，只接受一个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"alert('hehe')"</span>)    <span class="comment">//hehe</span></span><br></pre></td></tr></table></figure></p>
<p>通过eval()执行的代码可以引用在包含环境中定义的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'haha'</span></span><br><span class="line"><span class="built_in">eval</span>(alert(a))</span><br></pre></td></tr></table></figure></p>
<p><strong>在eval()中创建的任何变量或函数都不会被提升</strong><br>严格模式下，在外部访问不到eval()中创建的任何变量和函数。</p>
<h4 id="5-7-1-3-Global对象的属性"><a href="#5-7-1-3-Global对象的属性" class="headerlink" title="5.7.1.3 Global对象的属性"></a>5.7.1.3 Global对象的属性</h4><p><code>undefined``NaN``Infinity``Object``Array``Function``Boolean``String``Number``Date``RegExp``Error``EvalError``RangeError``ReferenceError``SyntaxError``TypeError``URIError</code></p>
<h4 id="5-7-1-4-window对象"><a href="#5-7-1-4-window对象" class="headerlink" title="5.7.1.4 window对象"></a>5.7.1.4 window对象</h4><p>Web浏览器将Global这个全局对象作为window对象的一部分加以实现。<br>所以Global的所有变量和函数就都成为了window对象的属性。</p>
<h3 id="5-7-2-Math对象"><a href="#5-7-2-Math对象" class="headerlink" title="5.7.2 Math对象"></a>5.7.2 Math对象</h3><p><strong>Math 对象属性</strong><br>属性    描述<br>E    返回算术常量 e，即自然对数的底数（约等于2.718）。<br>LN2    返回 2 的自然对数（约等于0.693）。<br>LN10    返回 10 的自然对数（约等于2.302）。<br>LOG2E    返回以 2 为底的 e 的对数（约等于 1.414）。<br>LOG10E    返回以 10 为底的 e 的对数（约等于0.434）。<br>PI    返回圆周率（约等于3.14159）。<br>SQRT1_2    返回返回 2 的平方根的倒数（约等于 0.707）。<br>SQRT2    返回 2 的平方根（约等于 1.414）。<br><strong>Math 对象方法</strong><br>方法    描述<br>abs(x)    返回数的绝对值。<br>acos(x)    返回数的反余弦值。<br>asin(x)    返回数的反正弦值。<br>atan(x)    以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。<br>atan2(y,x)    返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。<br>ceil(x)    对数进行上舍入。<br>cos(x)    返回数的余弦。<br>exp(x)    返回 e 的指数。<br>floor(x)    对数进行下舍入。<br>log(x)    返回数的自然对数（底为e）。<br>max(x,y)    返回 x 和 y 中的最高值。<br>min(x,y)    返回 x 和 y 中的最低值。<br>pow(x,y)    返回 x 的 y 次幂。<br>random()    返回 0 ~ 1 之间的随机数。<br>round(x)    把数四舍五入为最接近的整数。<br>sin(x)    返回数的正弦。<br>sqrt(x)    返回数的平方根。<br>tan(x)    返回角的正切。<br>toSource()    返回该对象的源代码。<br>valueOf()    返回 Math 对象的原始值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">25.9</span>)   <span class="comment">//26</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">25.9</span>)  <span class="comment">//25</span></span><br></pre></td></tr></table></figure>
<h1 id="6-面向对象的程序设计"><a href="#6-面向对象的程序设计" class="headerlink" title="6.面向对象的程序设计"></a>6.面向对象的程序设计</h1><p>ES把对象定义为：<strong>无序属性集合</strong>。</p>
<h2 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1 理解对象"></a>6.1 理解对象</h2><p>键值对形式存在</p>
<h3 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h3><p>ES5定义了只有<strong>内部才用的特性</strong>，这些是给js引擎用的，js不能<em>直接</em>访问他们。为了表示是内部值用<strong>[]</strong>来表示！！</p>
<h4 id="6-1-1-1-数据属性"><a href="#6-1-1-1-数据属性" class="headerlink" title="6.1.1.1 数据属性"></a>6.1.1.1 数据属性</h4><p>数据属性包含一个数据值的<strong>位置</strong><br>在这个位置可以读取和写入值。数据属性有4个描述其行为的特性<br><code>[[Configurable]]</code>表示能否通过delete删除属性从而重新定义属性。默认为true，表示可以。<br><code>[[Enumerable]]</code>表示能否for-in循环返回属性。默认是true。<br><code>[[Writable]]</code>表示能否改写属性的值，默认为true<br><code>[[Value]]</code>包含这个属性的数据值。默认值为undefined。读写都是从这个位置查找的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Configurable\Enumerable\Writable 都是默认值为true，Value被设置为Nicholas</span></span><br></pre></td></tr></table></figure></p>
<p>要<strong>修改</strong>默认的特性，必须使用ES的<code>Object.defineProperty()</code>方法。<br>包含三个参数：属性所在对象+属性的名字+描述符的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,        <span class="comment">//只读的，非严格模式下，赋值被忽略，严格模式下报错</span></span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name);</span><br><span class="line">person.name = <span class="string">"Michael"</span>;</span><br><span class="line">alert(person.name);</span><br></pre></td></tr></table></figure></p>
<p><code>[[Configurable]]</code>一旦设置成false，<strong>就不能再把它变回可配置了</strong><br>配置为false后，修改除<code>writeable</code>之外的特性，都会报错。</p>
<h4 id="6-1-1-2-访问器属性"><a href="#6-1-1-2-访问器属性" class="headerlink" title="6.1.1.2 访问器属性"></a>6.1.1.2 访问器属性</h4><p>访问器属性不包含数据值。<br><code>[[Configurable]]</code> 能否通过delete删除属性从而重新定义属性。默认为true<br><code>[[Enumerable]]</code>能否通过for-in循环返回属性。默认为true<br><code>[[Get]]</code>在读取属性时调用的函数。默认为undefined<br><code>[[Set]]</code>在写入属性时调用的函数。默认为undefined<br>访问器不能直接定义，必须使用<code>Object.defineProperty()</code>方法来定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>不一定非要同时指定getter和setter。<br>只指定getter意味着<strong>属性不能写</strong>，尝试写入属性会被忽略。严格模式下，抛出错误。<br>只指定setter意味着<strong>属性不能读</strong>，尝试读取属性会返回undefined，严格模式报错。</p>
<h3 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;                <span class="comment">//数据属性</span></span><br><span class="line">        value: <span class="number">2004</span>           </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    edition: &#123;              <span class="comment">//数据属性</span></span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    year: &#123;            </span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        <span class="comment">//访问器属性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;        <span class="comment">//访问器属性</span></span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h3><p>ES的<code>Object.getOwnPropertyDescriptor()</code>方法，可以取得给定属性的描述符。<br>接收两个参数：属性所在对象+要读取其描述符的属性名称<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    year: &#123;            </span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);   <span class="comment">//★主要是通过这个属性来访问的</span></span><br><span class="line">alert(descriptor.value);          <span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable);   <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get);     <span class="comment">//"undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line">alert(descriptor.value);          <span class="comment">//undefined</span></span><br><span class="line">alert(descriptor.enumerable);     <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get);     <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h2><p>共同的缺点：同一个接口创建很多对象，会产生很多的重复代码</p>
<h3 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1 工厂模式"></a>6.2.1 工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="keyword">return</span> o;        <span class="comment">//★ return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line">person2.sayName();   <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎么知道一个对象的类型）。</p>
</blockquote>
<h3 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line">person2.sayName();   <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(person1.constructor == Person);  <span class="comment">//true</span></span><br><span class="line">alert(person2.constructor == Person);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>优点：<br>没有显式的创建对象<br>直接将属性和方法赋给了this对象<br>没有return属性<br>实例标识为一种特定的类型<br>缺点：<br><strong>必须大写</strong>P</p>
<h4 id="6-2-2-1-构造函数当作函数"><a href="#6-2-2-1-构造函数当作函数" class="headerlink" title="6.2.2.1 构造函数当作函数"></a>6.2.2.1 构造函数当作函数</h4><p>只要通过<code>new</code>操作符来调用，那它就可以作为构造函数<br>如果不通过new调用，就和普通函数一样，普通函数<code>this</code>指向<code>window</code></p>
<h4 id="6-2-2-2-构造函数的问题"><a href="#6-2-2-2-构造函数的问题" class="headerlink" title="6.2.2.2 构造函数的问题"></a>6.2.2.2 构造函数的问题</h4><p>每个方法都要在实例上重新创建一遍，导致创建很多没必要的函数方法。</p>
<h3 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h3><p>每个函数都有一个prototype属性，这个属性是一个<strong>指针</strong>，指向一个对象，这个对象包含所有实例共享的属性和方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(Person.prototype.isPrototypeOf(person1));  <span class="comment">//true</span></span><br><span class="line">alert(Person.prototype.isPrototypeOf(person2));  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//only works if Object.getPrototypeOf() is available</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.getPrototypeOf)&#123;</span><br><span class="line">    alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype);  <span class="comment">//true</span></span><br><span class="line">    alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);  <span class="comment">//"Nicholas"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-3-1-理解原型对象"><a href="#6-2-3-1-理解原型对象" class="headerlink" title="6.2.3.1 理解原型对象"></a>6.2.3.1 理解原型对象</h4><p>所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。<br><strong>实例对象</strong>也包含一个指针，指向构造函数的原型对象，这个指针叫[[Prototype]],Firefox、Safari、Chrome在每个对象上都支持一个属性<strong>proto</strong>;在其他中是完全不可见的。<br>Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。</p>
<p><code>isPrototypeOf()</code>方法来确定对象之间是否在原型上。<br><code>hasOwnProperty()</code>检查是否存在于实例中。<br><code>Object.getPrototypeOf()</code>返回[[Prototype]]的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);         <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>原型最初<strong>只包含</strong><code>constructor</code>属性，而该属性也是共享的，因此可以通过对象实例访问。<br><code>delete</code>删除实例属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> person1.name;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-3-2-原型与in操作符"><a href="#6-2-3-2-原型与in操作符" class="headerlink" title="6.2.3.2 原型与in操作符"></a>6.2.3.2 原型与in操作符</h4><p><code>for-in</code>可以访问实例+原型中的属性，返回true<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> person1  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>判断是否在原型上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<strong>原型</strong>上定义了<strong>[[Enumerable]]标记为false的属性</strong>（不可枚举），但在<strong>实例</strong>属性也会在for-in循环中返回，因为规定，所有开发人员定义的属性都是可以枚举的。<br><code>Object.keys()</code>取得对象上所有可枚举的<strong>实例</strong>属性,返回的是一个<strong>数组</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line">alert(keys);   <span class="comment">//"name,age,job,sayName"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">'Rob'</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.key(<span class="string">'p1'</span>);   <span class="comment">//查看的是实例的属性</span></span><br><span class="line">alert(p1keys);      <span class="comment">//"name,age"</span></span><br></pre></td></tr></table></figure></p>
<p><code>Object.getOwnPropertyNames()</code>得到所有实例属性，无论<strong>是否可枚举</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class="line">alert(keys);   <span class="comment">//"constructor,name,age,job,sayName"</span></span><br></pre></td></tr></table></figure></p>
<p><em>包含了不可枚举的constructor</em></p>
<h4 id="6-2-3-3-更简单的原型语法"><a href="#6-2-3-3-更简单的原型语法" class="headerlink" title="6.2.3.3 更简单的原型语法"></a>6.2.3.3 更简单的原型语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;  <span class="comment">//这个是创建的新对象，所以它重新定义了constructor，不再指向Person，而是（Object构造函数）</span></span><br><span class="line">    <span class="keyword">constructor</span> : Person,    //因为上边注释的原因，所以在这里重新定义一下，就可以将<span class="keyword">constructor</span>重新定义回Person了</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job: "Software Engineer",</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br><span class="line">alert(friend <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></span><br><span class="line">alert(friend.constructor == Person);  <span class="comment">//true    //如果上边没有重新定义的话，这里是false</span></span><br><span class="line">alert(friend.constructor == <span class="built_in">Object</span>);  <span class="comment">//false   //如果上边没有重新定义的话，这里是true</span></span><br></pre></td></tr></table></figure>
<p><strong>原生的constructor是不可以枚举的，但是重新定义的这个是可以枚举的[[Enumerable]]为true</strong><br><code>Object.defineProperty()</code>ES5的重设构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-3-4-原型的动态性"><a href="#6-2-3-4-原型的动态性" class="headerlink" title="6.2.3.4 原型的动态性"></a>6.2.3.4 原型的动态性</h4><p>实例与原型之间的链接只不过是一个<strong>指针</strong>，而非一个副本。<br>可以<strong>随时</strong>给原型添加属性和方法，并且能立即反映出来。但是如果原型被修改为另外一个对象，就等于切断了构造函数与最初原型之间的联系。<br><strong>实例中的指针仅指向原型，而不指向构造函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果var friend = new Person();写在这里，下边就不会报错了，因为按顺序执行，上边重定义后，这里访问的就是新的对象了</span></span><br><span class="line">friend.sayName();   <span class="comment">//error   ★这里报错是因为Person.prototype被重写了，所以friend已经调不到属性了</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-3-5-原型对象的原型"><a href="#6-2-3-5-原型对象的原型" class="headerlink" title="6.2.3.5 原型对象的原型"></a>6.2.3.5 原型对象的原型</h4><p>可以像修改自定义对象的原型一样修改原生对象的原型。<br><strong>不推荐重写对象</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;   <span class="comment">//进行重写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line">alert(msg.startsWith(<span class="string">"Hello"</span>));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-3-6-原型对象的问题"><a href="#6-2-3-6-原型对象的问题" class="headerlink" title="6.2.3.6 原型对象的问题"></a>6.2.3.6 原型对象的问题</h4><p>共享属性被修改，所有都被修改，没有私有属性。</p>
<h3 id="6-2-4-组合使用构造函数模式和原型模式-★★★★★"><a href="#6-2-4-组合使用构造函数模式和原型模式-★★★★★" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式  ★★★★★"></a>6.2.4 组合使用构造函数模式和原型模式  ★★★★★</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br><strong>使用最广泛，认同度最高</strong>的一种创建自定义类型的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;                   <span class="comment">//构造函数模式</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;                               <span class="comment">//原型模式         </span></span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-5-动态原型模式"><a href="#6-2-5-动态原型模式" class="headerlink" title="6.2.5 动态原型模式"></a>6.2.5 动态原型模式</h3><p>通过检查某个应该存在的方法是否有效，来决定是否初始化原型。–按需初始化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//properties</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.job = job;</span><br><span class="line"></span><br><span class="line"><span class="comment">//methods</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;      <span class="comment">//只在sayName这个方法不存在的情况下，才会将它添加到原型中</span></span><br><span class="line"></span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();   <span class="comment">//弹出Nicholas</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法不能使用对象字面量重写原型，重写会切断现有实例与新原型之间的联系。</p>
<h4 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6 寄生构造函数模式"></a>6.2.6 寄生构造函数模式</h4><p>前述几种都不适用的情况下，可以使用寄生构造函数模式<br>该函数作用仅仅是封装创建对象，然后返回新创建的对象。<br><strong>不推荐用</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;       </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//create the array</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//add the values</span></span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//assign the method</span></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//return it</span></span><br><span class="line">    <span class="keyword">return</span> values;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);     <span class="comment">//唯一和工厂模式的区别是，多了一个new！！！</span></span><br><span class="line">alert(colors.toPipedString()); <span class="comment">//"red|blue|green"</span></span><br><span class="line"></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> SpecialArray);    <span class="comment">//不能通过instanceof确定类型</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7 稳妥构造函数模式"></a>6.2.7 稳妥构造函数模式</h3><p>所谓稳妥，指的是没有公共属性，而且其方法也不引用this对象。<br>适用于安全环境中，这个环境禁用this和new<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="keyword">return</span> o;        <span class="comment">//★ return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();  <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure></p>
<p>friend中保存的是一个稳妥对象，除了调用sayName()方法外，没有别的方式可以访问其数据成员。<br>instanceof也没有意义(好像只有new才会产生关系，瞎猜的)</p>
<h2 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h2><h3 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1 原型链"></a>6.3.1 原型链</h3><p>原型链作为继承的主要方法。<br>利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inherit from SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();     <span class="comment">//这里非常非常非常重要，这里重写了SubType的原型，所以之前的原型就断掉了，以后也不要查找了。</span></span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());   <span class="comment">//true    查找顺序：1：实例 2：SubType.prototype(已变更) 3：SuperType.prototype</span></span><br><span class="line"></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType);   <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType);     <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));    <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-3-1-1别忘了默认的原型"><a href="#6-3-1-1别忘了默认的原型" class="headerlink" title="6.3.1.1别忘了默认的原型"></a>6.3.1.1别忘了默认的原型</h4><p>所有函数的默认原型都是Object的实例。<br>默认原型都会包含一个内部指针，指向Object.prototype。<br>这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。</p>
<h4 id="6-3-1-2-确定原型和实例的关系"><a href="#6-3-1-2-确定原型和实例的关系" class="headerlink" title="6.3.1.2 确定原型和实例的关系"></a>6.3.1.2 确定原型和实例的关系</h4><p><code>instanceof</code>确定<strong>原型和实例</strong>的关系<br><code>isPrototypeOf()</code>判断原型链中出现过的原型</p>
<h4 id="6-3-1-3-谨慎地定义方法"><a href="#6-3-1-3-谨慎地定义方法" class="headerlink" title="6.3.1.3 谨慎地定义方法"></a>6.3.1.3 谨慎地定义方法</h4><p>给原型添加方法的代码，一定要放在<strong>替换（重写）原型</strong>的语句<strong>之后</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inherit from SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//new method 添加新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//override existing method   重写超类</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//try to add new methods � this nullifies the previous line</span></span><br><span class="line">SubType.prototype = &#123;           <span class="comment">//重写原型</span></span><br><span class="line">    getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());   <span class="comment">//error!  //SubType.prototype已经被重写了，getSuperValue方法已经丢失了</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-3-1-4-原型链的问题"><a href="#6-3-1-4-原型链的问题" class="headerlink" title="6.3.1.4 原型链的问题"></a>6.3.1.4 原型链的问题</h4><p>1.还是共享问题<br>2.创建子类型的实例时，不能向超类型的构造函数中传递参数</p>
<h3 id="6-3-2借用构造函数"><a href="#6-3-2借用构造函数" class="headerlink" title="6.3.2借用构造函数"></a>6.3.2借用构造函数</h3><p>apply()和call()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//inherit from SuperType passing in an argument</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//instance property</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name);    <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age);     <span class="comment">//29</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6-3-2-1传递参数"><a href="#6-3-2-1传递参数" class="headerlink" title="6.3.2.1传递参数"></a>6.3.2.1传递参数</h4><p>相对原型链有一个很大的优势，在子类构造函数中向超类型构造函数传递参数。</p>
<h4 id="6-3-2-2借用构造函数问题"><a href="#6-3-2-2借用构造函数问题" class="headerlink" title="6.3.2.2借用构造函数问题"></a>6.3.2.2借用构造函数问题</h4><p>同构造函数：方法都在构造函数中定义，函数复用无从谈起。</p>
<h3 id="6-3-3-组合继承"><a href="#6-3-3-组合继承" class="headerlink" title="6.3.3 组合继承"></a>6.3.3 组合继承</h3><p>伪经典继承：<strong>原型链+借用构造函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;                     <span class="comment">//构造函数-创建对象</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//原型模式-创建对象</span></span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;  </span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);              <span class="comment">//借用构造函数-继承       第二次调用SuperType()，创建实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();         <span class="comment">//原型链-继承             第一次调用SuperType()，创建实例</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);  <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();      <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge();       <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);  <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName();      <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge();       <span class="comment">//27</span></span><br></pre></td></tr></table></figure></p>
<p><code>instanceof</code>和<code>isPrototypeOf()</code>都是可用的<br>调用两次构造函数：<br>一次是创建子类型原型的时候<br>另一次是在子类型构造函数内部</p>
<h3 id="6-3-4-原型式继承-浅复制"><a href="#6-3-4-原型式继承-浅复制" class="headerlink" title="6.3.4 原型式继承-浅复制"></a>6.3.4 原型式继承-浅复制</h3><p>浅复制原理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上边那几句就是浅复制的原理</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure></p>
<p><code>Object.create()</code>是ES5新增的原型式继承方法。<br>两个参数：新对象原型的对象+新对象定义额外属性的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);      <span class="comment">//用法</span></span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure></p>
<p>第二个参数与Object.defineProperties()方法格式相同<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"Greg"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(anotherPerson.name);  <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure></p>
<p>缺点：<br>1：每个构造函数只有一个原型，不能实现多重继承<br>2：不能很好的支持多参数或动态参数的父类<br>3：隐私性比较差，易被修改</p>
<h3 id="6-3-5寄生式继承"><a href="#6-3-5寄生式继承" class="headerlink" title="6.3.5寄生式继承"></a>6.3.5寄生式继承</h3><p>寄生式就是在原型式的基础上（不一定），对原型式进行扩充，然后放到一个<strong>函数内</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original);    <span class="comment">//创建一个新对象-不一定用原型式</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        <span class="comment">//增强这个对象</span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;                   <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();  <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure></p>
<p>缺点：<strong>函数复用率低</strong></p>
<h3 id="6-3-6-寄生组合式继承★★★★★"><a href="#6-3-6-寄生组合式继承★★★★★" class="headerlink" title="6.3.6 寄生组合式继承★★★★★"></a>6.3.6 寄生组合式继承★★★★★</h3><p><strong>原型式继承+原型链+借用构造函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//原型式继承--浅复制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型链继承--下边这个和SubType.prototype = new SuperType();是一个意思，下边这么写的意思是为了避免多次创建SuperType()的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);   <span class="comment">//create object</span></span><br><span class="line">    prototype.constructor = subType;               <span class="comment">//augment object</span></span><br><span class="line">    subType.prototype = prototype;                 <span class="comment">//assign object</span></span><br><span class="line">&#125;</span><br><span class="line">                        </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//借用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;  </span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);  <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();      <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge();       <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);  <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName();      <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge();       <span class="comment">//27</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-7-浅拷贝"><a href="#6-3-7-浅拷贝" class="headerlink" title="6.3.7 浅拷贝"></a>6.3.7 浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123; </span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　c.uber = p;</span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> Doctor = extendCopy(Chinese);</span><br></pre></td></tr></table></figure>
<h3 id="6-3-8-深拷贝"><a href="#6-3-8-深拷贝" class="headerlink" title="6.3.8 深拷贝"></a>6.3.8 深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p是</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">　　　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">　　　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line">　　　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　　c[i] = p[i];</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> Doctor = deepCopy(Chinese);</span><br></pre></td></tr></table></figure>
<h1 id="7-函数表达式"><a href="#7-函数表达式" class="headerlink" title="7.函数表达式"></a>7.函数表达式</h1><p>函数声明和函数表达式</p>

					</div>


					<div class="content-tag">

<a class="tag-link" href="/tags/javascript/">javascript</a>, <a class="tag-link" href="/tags/js/">js</a>, <a class="tag-link" href="/tags/note/">note</a>, <a class="tag-link" href="/tags/笔记/">笔记</a>

					</div>



				</article>
			</div>

		</div>

		<div class="panel-post-nav">
			<div class="box-post-nav">


					<a href="/2016/03/20/HTTP-TCP协议-笔记/" title="HTTP/TCP协议---笔记">&larr; Prev</a>



					<a href="/2016/03/20/javascript高性能-笔记/" title="javascript高性能---笔记">Next &rarr;</a>


			</div>
		</div>
		<div class="content-comments">
		
  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/20/javascript高级程序设计-笔记/index.html" data-title="javascript高级程序设计---笔记" data-url="/2016/03/20/javascript高级程序设计-笔记/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'pengweb'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  
		</div>
		

	</div>

	<div class="layout-footer" style="clear: both">
		<div class="panel-footer">
			<div class="box-footer">
				<footer class="footer">
					<p class="cr">&copy; 2016 <a href="https://github.com/pengweb"  target="_blank" target="_blank">Pengzhang</a> 
					<span class="theme">Powered: <a href="https://github.com/pengweb/pengweb.github.io" target="_blank">pengweb.net</a>, 京ICP备: <a href="" target="_blank">15017479</a></span>
					</p>

					
				</footer>
			</div>
		</div>
	</div>




</body>
</html>
