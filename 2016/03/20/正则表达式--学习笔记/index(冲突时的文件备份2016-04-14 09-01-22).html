<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title> 正则表达式--学习笔记 | 张鹏的全栈之路 </title>
	<meta property="og:title" content=" 正则表达式--学习笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:title" content=" 正则表达式--学习笔记 | 张鹏的全栈之路 ">

	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary">

	<meta name="description" content=" 正则表达式--学习笔记 | 张鹏的全栈之路 ">
	<meta property="og:description" content=" 正则表达式--学习笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:description" content=" 正则表达式--学习笔记 | 张鹏的全栈之路 " />

	<link rel="icon" type="image/x-icon" href="/asset/img/favicon.png">

	<link rel="image_src" href="/asset/img/logo.png" >
	<meta property="og:image" content="/asset/img/logo.png" />

	<link href="http://yoursite.com/atom.xml" title="张鹏的全栈之路" type="application/atom+xml" rel="alternative">

	<link rel="canonical" href="/2016/03/20/正则表达式--学习笔记/index.html">

	<link rel="stylesheet" href="/asset/css/style.css">

</head>

<body>

	<div class="layout-header">
		<header class="header">
			<div class="layout-logo">
				<div class="panel-logo">

					<div class="box-logo box-log-md">
						<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
					</div>
					<div class="box-main-title">
						<h5 style="text-align: center">
							<span>Love life,love ourselves！--Pengzhang</span>
						</h5>
					</div>
					<div class="box-sub-title">

					</div>
				</div>
			</div>
			<div class="layout-menu">
				<div class="box-logo box-log-xs">
					<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
				</div>
				<div class="box-menu-list">
					<nav class="page-nav">
						<ul class="menu-list">

							<li class="box-menu-item"><a href="/"><span class="menu-item">HOME</span></a></li>

							<li class="box-menu-item"><a href="/tags/js"><span class="menu-item">Javascript</span></a></li>

							<li class="box-menu-item"><a href="/tags/nodejs"><span class="menu-item">Node.js</span></a></li>

							<li class="box-menu-item"><a href="/tags/html"><span class="menu-item">Html</span></a></li>

							<li class="box-menu-item"><a href="/tags/css"><span class="menu-item">Css</span></a></li>

							<li class="box-menu-item"><a href="/tags/note"><span class="menu-item">Note</span></a></li>

							<li class="box-menu-item"><a href="/tags/others"><span class="menu-item">Others</span></a></li>

						</ul>
					</nav>

				</div>
			</div>
		</header>
	</div>

	<div class="layout-content">


		<div class="row panel-content panel-post-item">
			<div class="box-post-item">
				<article class="post-item" itemscope itemtype="http://schema.org/Article">




					<p class="content-meta">
						<span class="meta-date" itemprop="datePublished" content="2016-03-20">2016-03-20</span>


					</p>


					<h2 class="box-content-title">
						<a href="/2016/03/20/正则表达式--学习笔记/"  itemprop="url"><span class="content-title" itemprop="name">正则表达式--学习笔记</span></a>
					</h2>

					<div class="content post-item-content" itemprop="articleBody">

<h1 id="ES5正则表达式"><a href="#ES5正则表达式" class="headerlink" title="ES5正则表达式"></a>ES5正则表达式</h1><h3 id="1-两种语法"><a href="#1-两种语法" class="headerlink" title="1.两种语法"></a>1.两种语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var patt = new RegExp(&apos;abc&apos;,&apos;g&apos;)</span><br><span class="line">//或者</span><br><span class="line">var regex = new RegExp(/xyz/i);</span><br></pre></td></tr></table></figure>
<p>查找abc,其中的g是修饰符，表示全局的<br>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var patt = /abc/g</span><br></pre></td></tr></table></figure></p>
<p>意思和上边相同</p>
<h3 id="2-三种方法"><a href="#2-三种方法" class="headerlink" title="2.三种方法"></a>2.三种方法</h3><p>test()     //返回true或者false<br>exec()     //返回的<strong>是数值，是数组</strong>，重复数值只显示一次<br>match()    //返回的<strong>是数值，是数组</strong>，重复数值显示多次</p>
<p><strong>exec和match区别</strong><br>var reg = /abc/g<br>var str = “1abc2,3abc4”<br>console.log(reg.exec(str))    //返回abc        只匹配一个<br>console.log(str.match(reg))   //返回abc,abc      匹配多个</p>
<p>补：<br>replace()<br>search()<br>split()</p>
<h3 id="3-常用元字符"><a href="#3-常用元字符" class="headerlink" title="3.常用元字符"></a>3.常用元字符</h3><p>.    匹配除换行符以外的其他字符<br>\w   匹配字母或数字或下划线或<br>\s   匹配任意的空白字符<br>\d   匹配数字<br>\b   匹配单词的开始或结束<br>\n   匹配新行<br>\r   匹配行首<br>^    匹配字符串的开始<br>$    匹配字符串的结束</p>
<h3 id="4-字符转义"><a href="#4-字符转义" class="headerlink" title="4.字符转义"></a>4.字符转义</h3><p>\    一般.和*还有()都需要</p>
<h3 id="5-限定符-重复"><a href="#5-限定符-重复" class="headerlink" title="5.限定符-重复"></a>5.限定符-重复</h3><p>*    重复0次或更多次<br>+    重复1次或更多次<br>?    重复0次或1次<br>{n}  重复n次<br>{n,} 重复n或更多次<br>{n,m}重复n到m次</p>
<h3 id="6-字符类-查找字符集合"><a href="#6-字符类-查找字符集合" class="headerlink" title="6.字符类-查找字符集合"></a>6.字符类-查找字符集合</h3><p>[]    匹配[]内的元素，字符之前是或的关系,<strong>返回也是一个字符而不是一个单词</strong><br>例：<br>[.?!] 匹配.或?或!<br>[a-z] 匹配a到z之间的数任意一个字符<br>[A-Z] 匹配A到Z<br>[0-9] 匹配0到9</p>
<h3 id="7-分支条件-类似于或的关系"><a href="#7-分支条件-类似于或的关系" class="headerlink" title="7.分支条件-类似于或的关系"></a>7.分支条件-类似于或的关系</h3><p>|    两种规则可以通过|来实现或的关系</p>
<h3 id="8-分组-就是上边的重复，只是对象不是单字符了"><a href="#8-分组-就是上边的重复，只是对象不是单字符了" class="headerlink" title="8.分组-就是上边的重复，只是对象不是单字符了"></a>8.分组-就是上边的重复，只是对象不是单字符了</h3><p>()    被括起来的进行分组<br>例：<br>(\d{1,3}){3}    表示一个1到3位的数字，重复三遍–就是三个三位数字</p>
<h3 id="9-反义–和元字符意思相反"><a href="#9-反义–和元字符意思相反" class="headerlink" title="9.反义–和元字符意思相反"></a>9.反义–和元字符意思相反</h3><p>\W        匹配任意不是字母，数字，下划线，汉字<br>\S        匹配任意不是空白符的字符<br>\D        匹配任意不是数字的字符<br>\B        匹配任意不是单词的开始或结束位置<br>[\^x]     匹配任意除了x以外的任意字符<br>[\^aeiou] 匹配除了aeiou以外的任意字符</p>
<h3 id="10-向后引用–取到匹配值返回数组"><a href="#10-向后引用–取到匹配值返回数组" class="headerlink" title="10.向后引用–取到匹配值返回数组"></a>10.向后引用–取到匹配值返回数组</h3><p>(exp)         和分组很像，都是用括号括起来，但是这里返回的是查到符合exp的<strong>数组</strong>,而分组不反回数组<br>(?<name>exp)  和上边效果一样，只不过他返回到数组有名字，是name<br>(?:exp)       不捕获符合exp的元素，也不返回成一个数组</name></p>
<h3 id="11-零宽断言–一般就是只查到这个词之后向前找或者向后找"><a href="#11-零宽断言–一般就是只查到这个词之后向前找或者向后找" class="headerlink" title="11.零宽断言–一般就是只查到这个词之后向前找或者向后找"></a>11.零宽断言–一般就是只查到这个词之后向前找或者向后找</h3><p>(?=exp)    匹配到exp的元素，向他前边找要匹配的元素 例:\b\w+(?=ing\b) ing前边要有字符,且一直向前找到头返回字符串<br>(?&lt;=exp)   匹配到exp后边的位置</p>
<h3 id="12-负向零宽断言–和反义字符-x-差不多是一个意思"><a href="#12-负向零宽断言–和反义字符-x-差不多是一个意思" class="headerlink" title="12.负向零宽断言–和反义字符[^x]差不多是一个意思"></a>12.负向零宽断言–和反义字符[^x]差不多是一个意思</h3><p>(?!exp)    匹配不包含exp规则的字符 例：\b\w<em>q(?!u)\w</em>\b  表示q后边是一个非u的字符</p>
<p>(?&lt;!exp)   匹配exp前边的位置  (?&lt;![a-z])\d{7}返回七位数字，且他们前边不能是小写字母</p>
<h3 id="13-贪婪–匹配尽可能多的字符"><a href="#13-贪婪–匹配尽可能多的字符" class="headerlink" title="13.贪婪–匹配尽可能多的字符"></a>13.贪婪–匹配尽可能多的字符</h3><p>a.*b     匹配字符串中最长的从a到b的字符串，可以理解为从第一个a开始找，一直找到最后一个b结束</p>
<h3 id="14-懒惰–匹配从第一个字符到最近的结束字符的字符串"><a href="#14-懒惰–匹配从第一个字符到最近的结束字符的字符串" class="headerlink" title="14.懒惰–匹配从第一个字符到最近的结束字符的字符串"></a>14.懒惰–匹配从第一个字符到最近的结束字符的字符串</h3><p>*?    重复任意次，但尽可能少重复 例：a.*?b  原式：aabab  匹配到：aab  ab<br>+?    重复1次或任意次，但尽可能少重复<br>??    重复n次或更多次，但尽可能少重复<br>{n,m}?重复n次到m次，但尽可能少重复<br>{n,}? 重复n次或更多次，但尽可能少重复</p>
<h1 id="ES6正则表达式"><a href="#ES6正则表达式" class="headerlink" title="ES6正则表达式"></a>ES6正则表达式</h1><p>1字符=2字节或者4字节</p>
<h3 id="1-RegExp构造函数"><a href="#1-RegExp构造函数" class="headerlink" title="1.RegExp构造函数"></a>1.RegExp构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, i);     <span class="comment">//ES5不可以这么声明</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>)              <span class="comment">//取i而不是ig</span></span><br></pre></td></tr></table></figure>
<h3 id="2-字符串方法："><a href="#2-字符串方法：" class="headerlink" title="2.字符串方法："></a>2.字符串方法：</h3><p>match()、replace()、search()和split()<br>在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<h3 id="3-u修饰符"><a href="#3-u修饰符" class="headerlink" title="3.u修饰符"></a>3.u修饰符</h3><p>含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>)</span><br><span class="line"><span class="comment">// false   加上u后，识别后边的'\uD83D\uDC2A'为一个字符不能拆开，前边匹配的只是它的一部分，所以是false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-点字符"><a href="#3-1-点字符" class="headerlink" title="3.1 点字符"></a>3.1 点字符</h4><p>点.字符是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/^.$/</span>.test(s) <span class="comment">// false    无法识别4字节编码字符</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true    只是针对识别4个字节的编码</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-Unicode字符表示法"><a href="#3-2-Unicode字符表示法" class="headerlink" title="3.2 Unicode字符表示法"></a>3.2 Unicode字符表示法</h4><p>使用<strong>大括号</strong>表示Unicode字符，u修饰符(/后边的那个)，才能识别。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">'a'</span>) <span class="comment">// false    第一个\u仅仅是字符编码的固定格式，没有第二个u的话，这个式子就不是识别4字节的方法，而是普通的两字节</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;<span class="number">20</span>BB7&#125;/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-量词"><a href="#3-3-量词" class="headerlink" title="3.3 量词"></a>3.3 量词</h4><p>使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// false   没有u，还无法识别前边那个𠮷</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-预定义模式"><a href="#3-4-预定义模式" class="headerlink" title="3.4 预定义模式"></a>3.4 预定义模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\S$/.test(<span class="string">'𠮷'</span>) <span class="comment">// false  上面代码的\S是预定义模式，匹配所有不是空格的字符,无法识别𠮷</span></span><br><span class="line">/^\S$/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true  上面代码的\S是预定义模式，匹配所有不是空格的字符</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-i修饰符"><a href="#3-5-i修饰符" class="headerlink" title="3.5 i修饰符"></a>3.5 i修饰符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\u004B与\u212A都是大写的K,证明\u212A是非规范的</span></span><br><span class="line"></span><br><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true    只有加u才能识别出来</span></span><br></pre></td></tr></table></figure>
<h3 id="4-y修饰符"><a href="#4-y修饰符" class="headerlink" title="4.y修饰符"></a>4.y修饰符</h3><p>除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。<br>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"><span class="comment">//第一次执行，exec只能取一次</span></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"><span class="comment">//第二次执行</span></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null      //紧连的是一个`—`所以为null</span></span><br></pre></td></tr></table></figure>
<p>使用<code>lastIndex</code>属性，可以更好地说明y修饰符,<strong>不包含位置字符</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/y</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">'xaya'</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">'xaxa'</span>);</span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p><strong>y修饰符号隐含了头部匹配的标志</strong> <code>ˆ</code><br>在split方法里，如果匹配成功<strong>意味着</strong>第一个成员肯定split括号内的参数，参数被替换后变成都逗号，逗号前边就肯定是个空字符了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有找到匹配</span></span><br><span class="line"><span class="string">'x##'</span>.split(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ 'x##' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到两个匹配</span></span><br><span class="line"><span class="string">'##x'</span>.split(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ '', '', 'x' ]</span></span><br></pre></td></tr></table></figure></p>
<p>用途：可以判断是否含有非法字符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN_Y = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_G  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-sticky属性"><a href="#5-sticky属性" class="headerlink" title="5.sticky属性"></a>5.sticky属性</h3><p>判断是否设置了y修饰符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-flags属性"><a href="#6-flags属性" class="headerlink" title="6.flags属性"></a>6.flags属性</h3><p>返回正则表达式的修饰符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的source属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.source</span><br><span class="line"><span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的flags属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.flags</span><br><span class="line"><span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="7-RegExp-escape"><a href="#7-RegExp-escape" class="headerlink" title="7.RegExp.escape()"></a>7.RegExp.escape()</h3><p>字符串必须转义，才能作为正则模式。<br>未放入ES7，所以暂时不讨论</p>
<h3 id="8-后行断言"><a href="#8-后行断言" class="headerlink" title="8.后行断言"></a>8.后行断言</h3><p><strong>先行断言</strong>指的是，x只有在y前面才匹配，必须写成/x(?=y)/<br>比如，只匹配百分号之前的数字，要写成/\d+(?=%)/</p>
<p><strong>先行否定断言</strong>指的是，x只有不在y前面才匹配，必须写成/x(?!y)/<br>比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p>
<p><strong>后行断言</strong>正好与”先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/<br>比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/</p>
<p><strong>后行否定断言</strong>则与”先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/<br>比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。</p>
<p>参考文献：<a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="external">http://www.jb51.net/tools/zhengze.html</a><br>参考文献：<a href="http://es6.ruanyifeng.com/#docs/regex" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/regex</a></p>

					</div>


					<div class="content-tag">

<a class="tag-link" href="/tags/note/">note</a>, <a class="tag-link" href="/tags/others/">others</a>, <a class="tag-link" href="/tags/笔记/">笔记</a>

					</div>



				</article>
			</div>

		</div>

		<div class="panel-post-nav">
			<div class="box-post-nav">


					<a href="/2016/03/21/Centos-Nodejs-Xampp服务器环境搭建/" title="Centos+Nodejs/Xampp服务器环境搭建">&larr; Prev</a>



					<a href="/2016/03/20/HTML--学习笔记/" title="HTML--学习笔记">Next &rarr;</a>


			</div>
		</div>
		<div class="content-comments">
		
  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/20/正则表达式--学习笔记/index.html" data-title="正则表达式--学习笔记" data-url="/2016/03/20/正则表达式--学习笔记/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'pengweb'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  
		</div>
		

	</div>

	<div class="layout-footer" style="clear: both">
		<div class="panel-footer">
			<div class="box-footer">
				<footer class="footer">
					<p class="cr">&copy; 2016 <a href="https://github.com/pengweb"  target="_blank" target="_blank">Pengzhang</a> 
					<span class="theme">Powered: <a href="https://github.com/pengweb/pengweb.github.io" target="_blank">pengweb.net</a>, 京ICP备: <a href="" target="_blank">15017479</a></span>
					</p>

					
				</footer>
			</div>
		</div>
	</div>




</body>
</html>
