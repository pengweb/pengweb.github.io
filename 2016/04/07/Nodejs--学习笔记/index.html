<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title> Nodejs--学习笔记 | 张鹏的全栈之路 </title>
	<meta property="og:title" content=" Nodejs--学习笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:title" content=" Nodejs--学习笔记 | 张鹏的全栈之路 ">

	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary">

	<meta name="description" content=" Nodejs--学习笔记 | 张鹏的全栈之路 ">
	<meta property="og:description" content=" Nodejs--学习笔记 | 张鹏的全栈之路 " />
	<meta name="twitter:description" content=" Nodejs--学习笔记 | 张鹏的全栈之路 " />

	<link rel="icon" type="image/x-icon" href="/asset/img/favicon.png">

	<link rel="image_src" href="/asset/img/logo.png" >
	<meta property="og:image" content="/asset/img/logo.png" />

	<link href="http://yoursite.com/atom.xml" title="张鹏的全栈之路" type="application/atom+xml" rel="alternative">

	<link rel="canonical" href="/2016/04/07/Nodejs--学习笔记/index.html">

	<link rel="stylesheet" href="/asset/css/style.css">

</head>

<body>

	<div class="layout-header">
		<header class="header">
			<div class="layout-logo">
				<div class="panel-logo">

					<div class="box-logo box-log-md">
						<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
					</div>
					<div class="box-main-title">
						<h5 style="text-align: center">
							<span>Love life,love ourselves！--Pengzhang</span>
						</h5>
					</div>
					<div class="box-sub-title">

					</div>
				</div>
			</div>
			<div class="layout-menu">
				<div class="box-logo box-log-xs">
					<a href="/" title="张鹏的全栈之路"><img src="/asset/img/logo.png" class="img-logo"></a>
				</div>
				<div class="box-menu-list">
					<nav class="page-nav">
						<ul class="menu-list">

							<li class="box-menu-item"><a href="/"><span class="menu-item">HOME</span></a></li>

							<li class="box-menu-item"><a href="/tags/js"><span class="menu-item">Javascript</span></a></li>

							<li class="box-menu-item"><a href="/tags/nodejs"><span class="menu-item">Node.js</span></a></li>

							<li class="box-menu-item"><a href="/tags/html"><span class="menu-item">Html</span></a></li>

							<li class="box-menu-item"><a href="/tags/css"><span class="menu-item">Css</span></a></li>

							<li class="box-menu-item"><a href="/tags/note"><span class="menu-item">Note</span></a></li>

							<li class="box-menu-item"><a href="/tags/others"><span class="menu-item">Others</span></a></li>

						</ul>
					</nav>

				</div>
			</div>
		</header>
	</div>

	<div class="layout-content">


		<div class="row panel-content panel-post-item">
			<div class="box-post-item">
				<article class="post-item" itemscope itemtype="http://schema.org/Article">




					<p class="content-meta">
						<span class="meta-date" itemprop="datePublished" content="2016-04-07">2016-04-07</span>


					</p>


					<h2 class="box-content-title">
						<a href="/2016/04/07/Nodejs--学习笔记/"  itemprop="url"><span class="content-title" itemprop="name">Nodejs--学习笔记</span></a>
					</h2>

					<div class="content post-item-content" itemprop="articleBody">

<p><strong>创建Nodejs应用</strong><br>步骤一、引入 required 模块<br><figure class="highlight js"><figcaption><span>var http = require("http");```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">步骤一、创建服务器</span><br><span class="line">使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 <span class="number">8888</span> 端口。 函数通过 request, response 参数来接收和响应数据。</span><br><span class="line">创建一个叫 server.js 的文件</span><br><span class="line"><span class="string">``</span><span class="string">`js var http = require('http');</span><br><span class="line"></span><br><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line"></span><br><span class="line">// 发送 HTTP 头部</span><br><span class="line">// HTTP 状态值: 200 : OK</span><br><span class="line">// 内容类型: text/plain</span><br><span class="line">response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;);</span><br><span class="line"></span><br><span class="line">// 发送响应数据 "Hello World"</span><br><span class="line">response.end('Hello World\n');</span><br><span class="line">&#125;).listen(8888);</span><br><span class="line"></span><br><span class="line">// 终端打印如下信息</span><br><span class="line">console.log('Server running at http://127.0.0.1:8888/');</span></span><br></pre></td></tr></table></figure></p>
<p>二、运行服务器<br><figure class="highlight"><figcaption><span>node server.js```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong&gt;NPM使用介绍：&lt;/strong&gt;</span><br><span class="line">升级npm</span><br><span class="line">```js npm install npm -g</span><br></pre></td></tr></table></figure></p>
<p>全局安装和局部安装：<br><figure class="highlight"><figcaption><span>npm install express # 本地安装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g # 全局安装</span><br></pre></td></tr></table></figure></p>
<p>本地安装</p>
<ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。<br>全局安装</li>
<li>将安装包放在 /usr/local 下。</li>
<li>可以直接在命令行里使用。</li>
<li>不能通过 require() 来引入本地安装的包。</li>
</ol>
<p>Package.json 属性说明<br>name - 包名。<br>version - 包的版本号。<br>description - 包的描述。<br>homepage - 包的官网 url 。<br>author - 包的作者姓名。<br>contributors - 包的其他贡献者姓名。<br>dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。<br>repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。<br>main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(“express”)。<br>keywords - 关键字</p>
<p>卸载模块<br>我们可以使用以下命令来卸载 Node.js 模块。<br>$ npm uninstall express<br>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：<br>$ npm ls</p>
<p>更新模块<br>我们可以使用以下命令更新模块：<br>$ npm update express<br>搜索模块<br>使用以下来搜索模块：<br>$ npm search express</p>
<p>版本号<br>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。<br>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。<br>如果只是修复bug，需要更新Z位。<br>如果是新增了功能，但是向下兼容，需要更新Y位。<br>如果有大变动，向下不兼容，需要更新X位。</p>
<p><strong>Node.js REPL(交互式解释器)</strong></p>
<p>REPL 命令<br>ctrl + c - 退出当前终端。<br>ctrl + c 按下两次 - 退出 Node REPL。<br>ctrl + d - 退出 Node REPL.<br>向上/向下 键 - 查看输入的历史命令<br>tab 键 - 列出当前命令<br>.help - 列出使用命令<br>.break - 退出多行表达式<br>.clear - 退出多行表达式<br>.save filename - 保存当前的 Node REPL 会话到指定文件<br>.load filename - 载入当前 Node REPL 会话的文件内容。</p>
<p><strong>Node.js 回调函数</strong></p>
<p>Node.js 异步编程的直接体现就是回调。<br>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。<br>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。<br>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求<br><figure class="highlight js"><figcaption><span>Node.js 事件循环```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。</span><br><span class="line">Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。</span><br><span class="line">Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</span><br><span class="line">Node.js 单线程类似进入一个<span class="keyword">while</span>(<span class="literal">true</span>)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</span><br><span class="line"><span class="string">``</span><span class="string">`js // 引入 events 模块</span><br><span class="line">var events = require('events');</span><br><span class="line">// 创建 eventEmitter 对象</span><br><span class="line">var eventEmitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">// 创建事件处理程序</span><br><span class="line">var connectHandler = function connected() &#123;</span><br><span class="line">console.log('连接成功。');</span><br><span class="line"></span><br><span class="line">// 触发 data_received 事件</span><br><span class="line">eventEmitter.emit('data_received');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定 connection 事件处理程序</span><br><span class="line">eventEmitter.on('connection', connectHandler);</span><br><span class="line"></span><br><span class="line">// 使用匿名函数绑定 data_received 事件</span><br><span class="line">eventEmitter.on('data_received', function()&#123;</span><br><span class="line">console.log('数据接收成功。');</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 触发 connection 事件</span><br><span class="line">eventEmitter.emit('connection');</span><br><span class="line"></span><br><span class="line">console.log("程序执行完毕。");</span></span><br></pre></td></tr></table></figure></p>
<p>连接成功。<br>数据接收成功。<br>程序执行完毕。</p>
<p>Node 应用程序是如何工作的？<br><figure class="highlight js"><figcaption><span>var fs = require("fs");</span><a href="//fs是用来读取的">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.stack);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><figcaption><span>Node.js EventEmitter```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</span><br><span class="line">Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</span><br><span class="line"></span><br><span class="line">EventEmitter 类</span><br><span class="line">events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</span><br><span class="line">你可以通过<span class="built_in">require</span>(<span class="string">"events"</span>);来访问该模块。</span><br><span class="line"><span class="string">``</span><span class="string">`js // 引入 events 模块</span><br><span class="line">var events = require('events');</span><br><span class="line">// 创建 eventEmitter 对象</span><br><span class="line">var eventEmitter = new events.EventEmitter();</span></span><br></pre></td></tr></table></figure>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 ‘error’ 事件。当添加新的监听器时，’newListener’ 事件会触发，当监听器被移除时，’removeListener’ 事件被触发。<br>下面我们用一个简单的例子说明 EventEmitter 的用法：<br><figure class="highlight js"><figcaption><span>//event.js 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">event.emit(<span class="string">'some_event'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>$ node event.js<br>some_event 事件触发</p>
<p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。<br>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<p>让我们以下面的例子解释这个过程：<br><figure class="highlight js"><figcaption><span>//event.js 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'arg1 参数'</span>, <span class="string">'arg2 参数'</span>);</span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，运行的结果如下：/p&gt;<br><figure class="highlight js"><figcaption><span>$ node event.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listener1 arg1 参数 arg2 参数</span><br><span class="line">listener2 arg1 参数 arg2 参数</span><br></pre></td></tr></table></figure></p>
<p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。<br>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。<br>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<p>实例<br><figure class="highlight js"><figcaption><span>var events = require('events');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listner1 = <span class="function"><span class="keyword">function</span> <span class="title">listner1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'监听器 listner1 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listner2 = <span class="function"><span class="keyword">function</span> <span class="title">listner2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'监听器 listner2 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listner1</span></span><br><span class="line">eventEmitter.addListener(<span class="string">'connection'</span>, listner1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listner2</span></span><br><span class="line">eventEmitter.on(<span class="string">'connection'</span>, listner2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventListeners = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除监绑定的 listner1 函数</span></span><br><span class="line">eventEmitter.removeListener(<span class="string">'connection'</span>, listner1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"listner1 不再受监听。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发连接事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line">eventListeners = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure></p>
<p>error 事件<br><figure class="highlight js"><figcaption><span>var events = require('events');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line">emitter.emit(<span class="string">'error'</span>);</span><br></pre></td></tr></table></figure></p>
<p>继承 EventEmitter<br>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。<br>为什么要这样做呢？原因有两点：<br>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。<br>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<p><strong>Node.js Buffer(缓冲区)<br></strong></p>
<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。<br>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。<br>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<p>创建 Buffer 类<br>Node Buffer 类可以通过多种方式来创建。<br>方法 1<br>创建长度为 10 字节的 Buffer 实例：<br><figure class="highlight js"><figcaption><span>var buf = new Buffer(10);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法 <span class="number">2</span></span><br><span class="line">通过给定的数组创建 Buffer 实例：</span><br><span class="line"><span class="string">``</span><span class="string">`js var buf = new Buffer([10, 20, 30, 40, 50]);</span></span><br></pre></td></tr></table></figure></p>
<p>方法 3<br>通过一个字符串来创建 Buffer 实例：<br><figure class="highlight js"><figcaption><span>var buf = new Buffer("www.runoob.com", "utf-8")```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">写入缓冲区</span><br><span class="line"></span><br><span class="line">写入 Node 缓冲区的语法如下所示：</span><br><span class="line"><span class="string">``</span><span class="string">`js buf.write(string[, offset][, length][, encoding])</span></span><br></pre></td></tr></table></figure></p>
<p>参数<br>参数描述如下：<br>string - 写入缓冲区的字符串。<br>offset - 缓冲区开始写入的索引值，默认为 0 。<br>length - 写入的字节数，默认为 buffer.length<br>encoding - 使用的编码。默认为 ‘utf8’ 。<br>返回值<br>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。<br>实例<br><figure class="highlight js"><figcaption><span>buf = new Buffer(256);</span><a href="//最长为256字节">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">len = buf.write(<span class="string">"www.runoob.com"</span>); <span class="comment">////存入的是二进制</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"写入字节数 : "</span>+ len);</span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为：<br><figure class="highlight js"><figcaption><span>$node main.js```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写入字节数 : <span class="number">14</span></span><br><span class="line"></span><br><span class="line">从缓冲区读取数据</span><br><span class="line">读取 Node 缓冲区数据的语法如下所示：</span><br><span class="line"><span class="string">``</span><span class="string">`js buf.toString([encoding][, start][, end]) //先将二进制转化成字符串，再将字符串转化成要输出的格式，例如ascii</span></span><br></pre></td></tr></table></figure></p>
<p>参数<br>参数描述如下：<br>encoding - 使用的编码。默认为 ‘utf8’ 。<br>start - 指定开始读取的索引位置，默认为 0。<br>end - 结束位置，默认为缓冲区的末尾。</p>
<p>将 Buffer 转换为 JSON 对象<br>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：<br><figure class="highlight js"><figcaption><span>buf.toJSON()</span><a href="//输出的就是二进制，不进行转换```">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缓冲区合并</span><br><span class="line">语法</span><br><span class="line">Node 缓冲区合并的语法如下所示：</span><br><span class="line"><span class="string">``</span><span class="string">`js Buffer.concat(list[, totalLength])</span></span><br></pre></td></tr></table></figure></p>
<p>参数<br>参数描述如下：<br>list - 用于合并的 Buffer 对象数组列表。<br>totalLength - 指定合并后Buffer对象的总长度。<br>返回值<br>返回一个多个成员合并的新 Buffer 对象。<br>实例<br><figure class="highlight js"><figcaption><span>var buffer1 = new Buffer('Pengweb ');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer2 = <span class="keyword">new</span> Buffer(<span class="string">'www.pengweb.com'</span>);</span><br><span class="line"><span class="keyword">var</span> buffer3 = Buffer.concat([buffer1,buffer2]); <span class="comment">//主要是这里合并</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"buffer3 内容: "</span> + buffer3.toString());</span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为：<br>buffer3 内容: Pengweb www.pengweb.com</p>
<p>下边是自己写的：<br><figure class="highlight js"><figcaption><span>var buf1=new Buffer(10);</span><a href="//要从新new一个才行">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len1 =buf1.write(<span class="string">"我自己的网站"</span>);</span><br><span class="line">con=Buffer.concat([buf1,buf]); <span class="comment">//合并的时候一定要是buf1，不能是len1</span></span><br><span class="line"><span class="built_in">console</span>.log(con.toString()); <span class="comment">//一定要读取出来才行</span></span><br></pre></td></tr></table></figure></p>
<p>缓冲区比较<br>语法<br>Node Buffer 比较的函数语法如下所示：<br><figure class="highlight js"><figcaption><span>buf.compare(otherBuffer);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">参数描述如下：</span><br><span class="line">otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。</span><br><span class="line">返回值</span><br><span class="line">返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</span><br><span class="line">实例</span><br><span class="line"><span class="string">``</span><span class="string">`js var buffer1 = new Buffer('ABC');</span><br><span class="line">var buffer2 = new Buffer('ABCD');</span><br><span class="line">var result = buffer1.compare(buffer2);</span><br><span class="line"></span><br><span class="line">if(result &amp;lt; 0) &#123;</span><br><span class="line">console.log(buffer1 + " 在 " + buffer2 + "之前");</span><br><span class="line">&#125;else if(result == 0)&#123;</span><br><span class="line">console.log(buffer1 + " 与 " + buffer2 + "相同");</span><br><span class="line">&#125;else &#123;</span><br><span class="line">console.log(buffer1 + " 在 " + buffer2 + "之后");</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为：<br>ABC在ABCD之前</p>
<p>拷贝缓冲区<br>语法<br>Node 缓冲区拷贝语法如下所示：<br><figure class="highlight js"><figcaption><span>buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">参数描述如下：</span><br><span class="line">targetBuffer - 要拷贝的 Buffer 对象。</span><br><span class="line">targetStart - 数字, 可选, 默认: <span class="number">0</span></span><br><span class="line">sourceStart - 数字, 可选, 默认: <span class="number">0</span></span><br><span class="line">sourceEnd - 数字, 可选, 默认: buffer.length</span><br><span class="line">返回值</span><br><span class="line">没有返回值。</span><br><span class="line">实例</span><br><span class="line"><span class="string">``</span><span class="string">`js var buffer1 = new Buffer('ABC');</span><br><span class="line">// 拷贝一个缓冲区</span><br><span class="line">var buffer2 = new Buffer(3);</span><br><span class="line">buffer1.copy(buffer2); //将buffer1拷贝给buffer3</span><br><span class="line">console.log("buffer2 content: " + buffer2.toString());</span></span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为：<br>buffer2 content: ABC</p>
<p>缓冲区裁剪<br>Node 缓冲区裁剪语法如下所示：<br><figure class="highlight js"><figcaption><span>buf.slice([start][, end])```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">参数描述如下：</span><br><span class="line">start - 数字, 可选, 默认: <span class="number">0</span></span><br><span class="line">end - 数字, 可选, 默认: buffer.length</span><br><span class="line">返回值</span><br><span class="line">返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</span><br><span class="line">实例</span><br><span class="line"><span class="string">``</span><span class="string">`js var buffer1 = new Buffer('runoob');</span><br><span class="line">// 剪切缓冲区</span><br><span class="line">var buffer2 = buffer1.slice(0,2); //这里是剪掉保留2位</span><br><span class="line">console.log("buffer2 content: " + buffer2.toString());</span></span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为：<br>buffer2 content: ru</p>
<p>缓冲区长度<br>语法<br>Node 缓冲区长度计算语法如下所示：<br><figure class="highlight js"><figcaption><span>buf.length;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回值</span><br><span class="line">返回 Buffer 对象所占据的内存长度。</span><br><span class="line">实例</span><br><span class="line"><span class="string">``</span><span class="string">`js var buffer = new Buffer('www.runoob.com');</span><br><span class="line">// 缓冲区长度</span><br><span class="line">console.log("buffer length: " + buffer.length);</span></span><br></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为：<br>buffer length: 14</p>
<p>Node.js Stream(流)</p>
<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。<br>Node.js，Stream 有四种流类型：<br>Readable - 可读操作。<br>Writable - 可写操作。<br>Duplex - 可读可写操作.<br>Transform - 操作被写入数据，然后读出结果。<br>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：<br>data - 当有数据可读时触发。<br>end - 没有更多的数据可读时触发。<br>error - 在接收和写入过程中发生错误时触发。<br>finish - 所有数据已被写入到底层系统时触发。</p>
<p>从流中读取数据<br><figure class="highlight js"><figcaption><span>var fs = require("fs");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置编码为 utf8。</span></span><br><span class="line">readerStream.setEncoding(<span class="string">'UTF8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&amp;gt; data, end, and error</span></span><br><span class="line">readerStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//结束时触发</span></span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.stack); <span class="comment">//错误时，触发原因</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<p>写入流<br><figure class="highlight js"><figcaption><span>var fs = require("fs");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">'我的地址：www.pengweb.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 utf8 编码写入数据</span></span><br><span class="line">writerStream.write(data,<span class="string">'UTF8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记文件末尾</span></span><br><span class="line">writerStream.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&amp;gt; data, end, and error</span></span><br><span class="line">writerStream.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"写入完成。"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">writerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：<br>$ node main.js<br>程序执行完毕<br>写入完成。<br>查看 output.txt 文件的内容：<br>$ cat output.txt<br>我的地址：www.pengweb.com</p>
<p>管道流<br>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。<br>我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。<br>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。<br><figure class="highlight js"><figcaption><span>var fs = require("fs");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道读写操作</span></span><br><span class="line"><span class="comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span></span><br><span class="line">readerStream.pipe(writerStream); <span class="comment">//会先清空目标文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<p>链式流<br>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。<br>接下来我们就是用管道和链式来压缩和解压文件。<br><figure class="highlight js"><figcaption><span>var fs = require("fs");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 input.txt 文件为 input.txt.gz</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt'</span>)</span><br><span class="line">.pipe(zlib.createGzip())</span><br><span class="line">.pipe(fs.createWriteStream(<span class="string">'input.txt.gz'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件压缩完成。"</span>);</span><br></pre></td></tr></table></figure></p>
<p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：<br><figure class="highlight js"><figcaption><span>var fs = require("fs");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压 input.txt.gz 文件为 input.txt</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt.gz'</span>)</span><br><span class="line">.pipe(zlib.createGunzip())</span><br><span class="line">.pipe(fs.createWriteStream(<span class="string">'input.txt'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件解压完成。"</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>Node.js模块系统</strong><br>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。<br>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>
<p>创建模块<br>有时候我们只是想把一个对象封装到模块中，格式如下：<br>//hello.js<br><figure class="highlight js"><figcaption><span>function Hello() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</span><br><span class="line">name = thyName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = Hello;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以直接获得这个对象了：<br>//main.js<br><figure class="highlight js"><figcaption><span>var Hello = require('./hello');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello = <span class="keyword">new</span> Hello(); <span class="comment">//这里一定要new出来 才能引用</span></span><br><span class="line">hello.setName(<span class="string">'BYVoid'</span>);</span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p>
<p>服务端的模块放在哪里<br>也许你已经注意到，我们已经在代码中使用了模块了。像这样：<br><figure class="highlight js"><figcaption><span>var http = require("http");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">http.createServer(...);</span><br></pre></td></tr></table></figure></p>
<p>Node.js中自带了一个叫做”http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。<br>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。<br>Node.js 的 require方法中的文件查找策略如下：<br>由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p>
<p><img class="alignnone size-full wp-image-6555" src="http://www.runoob.com/wp-content/uploads/2014/03/nodejs-require.jpg" alt="nodejs-require" width="479" height="601"></p>
<p>从文件模块缓存中加载<br>尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。<br>从原生模块加载<br>原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。<br>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。<br>从文件加载</p>
<p>require方法接受以下几种参数的传递：<br>http、fs、path等，原生模块。<br>./mod或../mod，相对路径的文件模块。<br>/pathtomodule/mod，绝对路径的文件模块。<br>mod，非原生模块的文件模块。</p>
<p><strong>Node.js 函数</strong></p>
<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：<br><figure class="highlight js"><figcaption><span>function say(word) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>) </span>&#123; <span class="comment">//say的变量是通过value来传的，而不能通过someFunction(value)来传！！</span></span><br><span class="line">someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(say, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！<br>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。<br>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>
<p>匿名函数：<br>function execute(someFunction, value) {<br>someFunction(value);<br>}</p>
<p>execute(function(word){ console.log(word) }, “Hello”); //Hello 传递的变量还是在后边定义</p>
<p>函数传递是如何让HTTP服务器工作的<br><figure class="highlight js"><figcaption><span>var http = require("http");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">response.end();</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>Node.js 路由</strong><br><a href="http://localhost:8888/start?foo=bar&amp;hello=world" target="_blank" rel="external">http://localhost:8888/start?foo=bar&amp;hello=world</a><br>start 是url.parse(string).pathname<br>foo=bar&amp;hello=world是url.parse(string).query<br>bar 是querystring(string)[“foo”]<br>world 是querystring(string)[“hello”]</p>
<p>//server.js<br><figure class="highlight js"><figcaption><span>var http = require("http");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line"></span><br><span class="line">route(pathname);</span><br><span class="line"></span><br><span class="line">response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure></p>
<p>//router.js<br><figure class="highlight js"><figcaption><span>function route(pathname) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = route; <span class="comment">//我这里用的是封装形式，所以下边start(router)而不是start(router.route)</span></span><br></pre></td></tr></table></figure></p>
<p>//index.js<br><figure class="highlight js"><figcaption><span>var server = require("./server");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line">server.start(router);</span><br></pre></td></tr></table></figure></p>
<p><strong>Node.js 全局对象</strong><br>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。<br>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。<br>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：<br>在最外层定义的变量；<br>全局对象的属性；</p>
<p>全局对象与全局变量<br>隐式定义的变量（未定义直接赋值的变量）。<br>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。<br>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。</p>
<p><strong>filename
</strong>filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>
<p><strong>dirname
</strong>dirname 表示当前执行脚本所在的目录。</p>
<p>setTimeout(cb, ms)<br>setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。<br>返回一个代表定时器的句柄值。</p>
<p>clearTimeout(t)<br>clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的计算器。<br><figure class="highlight js"><figcaption><span>function printHello()&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = setTimeout(printHello,<span class="number">2000</span>);</span><br><span class="line">clearTimeout(t); <span class="comment">//彻底清除t，不管t放在clear上还是下，都不在显示hello world</span></span><br></pre></td></tr></table></figure></p>
<p>setInterval(cb, ms)<br>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。<br>返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。<br>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p>
<p>console<br>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。<br>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。<br><figure class="highlight js"><figcaption><span>var counter = 10;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"计数: %d"</span>, counter); <span class="comment">//计数: 10</span></span><br></pre></td></tr></table></figure></p>
<p>process<br>process 是一个全局变量，即 global 对象的属性。<br>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。<br><figure class="highlight js"><figcaption><span>process.on('exit', function(code) &#123;</span><a href="//当进程准备退出时触发，所以放在最后显示">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 以下代码永远不会执行</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"该代码不会执行"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'退出码为:'</span>, code);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束"</span>);</span><br></pre></td></tr></table></figure></p>
<p>执行代码如下所示:<br><figure class="highlight js"><figcaption><span>程序执行结束</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">退出码为: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>属性：<br><figure class="highlight js"><figcaption><span>// 输出到终端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.write(<span class="string">"Hello World!"</span> + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过参数读取</span></span><br><span class="line"><span class="comment">//argv它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</span></span><br><span class="line">process.argv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(index + <span class="string">': '</span> + val);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取执行路局</span></span><br><span class="line"><span class="built_in">console</span>.log(process.execPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台信息</span></span><br><span class="line"><span class="built_in">console</span>.log(process.platform);</span><br></pre></td></tr></table></figure></p>
<p>$ node main.js<br><figure class="highlight js"><figcaption><span>Hello World!</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: node</span><br><span class="line"><span class="number">1</span>: <span class="regexp">/web/</span>www/node/main.js</span><br><span class="line">/usr/local/node/<span class="number">0.10</span><span class="number">.36</span>/bin/node</span><br><span class="line">darwin</span><br></pre></td></tr></table></figure></p>
<p>方法：<br><figure class="highlight js"><figcaption><span>// 输出当前目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'当前目录: '</span> + process.cwd());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出当前版本</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'当前版本: '</span> + process.version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出内存使用情况</span></span><br><span class="line"><span class="built_in">console</span>.log(process.memoryUsage());</span><br></pre></td></tr></table></figure></p>
<p>$ node main.js<br><figure class="highlight js"><figcaption><span>当前目录:</span><a href="/web/com/runoob/nodejs">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前版本: v0<span class="number">.10</span><span class="number">.36</span></span><br><span class="line">&#123; rss: <span class="number">12541952</span>, heapTotal: <span class="number">4083456</span>, heapUsed: <span class="number">2157056</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Node.js 常用工具</strong><br>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<p>util.inherits<br>util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。<br>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>util.inherits<br>util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。<br>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。<br><figure class="highlight js"><figcaption><span>util.inherits(Sub, Base);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</span><br><span class="line">同时，在原型中定义的属性不会被<span class="built_in">console</span>.log 作为对象的属性输出。</span><br><span class="line"></span><br><span class="line">util.inspect</span><br><span class="line">util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</span><br><span class="line">showHidden 是一个可选参数，如果值为 <span class="literal">true</span>，将会输出更多隐藏信息。</span><br><span class="line">depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归<span class="number">2</span>层，指定为 <span class="literal">null</span> 表示将不限递归层数完整遍历对象。 如果color 值为 <span class="literal">true</span>，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。</span><br><span class="line">特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。</span><br><span class="line"><span class="string">``</span><span class="string">`js var util = require('util');</span><br><span class="line">function Person() &#123;</span><br><span class="line">this.name = 'byvoid';</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Person();</span><br><span class="line">console.log(util.inspect(obj));</span><br><span class="line">console.log(util.inspect(obj, true));</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><figcaption><span>&#123; name: 'byvoid', toString: [Function] &#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; toString:</span><br><span class="line">&#123; [<span class="built_in">Function</span>]</span><br><span class="line">[prototype]: &#123; [<span class="keyword">constructor</span>]: [Circular] &#125;,</span><br><span class="line">[caller]: null,</span><br><span class="line">[length]: 0,</span><br><span class="line">[name]: '',</span><br><span class="line">[arguments]: null &#125;,</span><br><span class="line">name: 'byvoid' &#125;</span><br></pre></td></tr></table></figure>
<p>util.isArray(object)<br>如果给定的参数 “object” 是一个数组返回true，否则返回false。<br><figure class="highlight js"><figcaption><span>var util = require('util');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">util.isArray([])</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">util.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">util.isArray(&#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>util.isRegExp(object)<br>如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。<br><figure class="highlight js"><figcaption><span>var util = require('util');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">util.isRegExp(<span class="regexp">/some regexp/</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">util.isRegExp(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'another regexp'</span>))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">util.isRegExp(&#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>util.isDate(object)<br>如果给定的参数 “object” 是一个日期返回true，否则返回false。<br><figure class="highlight js"><figcaption><span>var util = require('util');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">util.isDate(<span class="built_in">Date</span>())</span><br><span class="line"><span class="comment">// false (without 'new' returns a String)</span></span><br><span class="line">util.isDate(&#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>util.isError(object)<br>如果给定的参数 “object” 是一个错误对象返回true，否则返回false。<br><figure class="highlight js"><figcaption><span>var util = require('util');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">util.isError(<span class="keyword">new</span> <span class="built_in">Error</span>())</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">util.isError(<span class="keyword">new</span> <span class="built_in">TypeError</span>())</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">util.isError(&#123; name: <span class="string">'Error'</span>, message: <span class="string">'an error occurred'</span> &#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Node.js 文件系统</strong><br>Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示：<br>var fs = require(“fs”)<br>异步和同步<br>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。<br>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。<br>建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。<br><figure class="highlight js"><figcaption><span>//异步读取</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'input.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"异步读取："</span>+data.toString());</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步读取</span></span><br><span class="line"><span class="keyword">var</span> data=fs.readFileSync(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"同步都去："</span>+data.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure></p>
<p>打开文件<br>语法<br>以下为在异步模式下打开文件的语法格式：<br><figure class="highlight js"><figcaption><span>fs.open(path, flags[, mode], callback)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">参数使用说明如下：</span><br><span class="line">path - 文件的路径。</span><br><span class="line">flags - 文件打开的行为。具体值详见下文。</span><br><span class="line">mode - 设置文件模式(权限)，文件创建默认权限为 <span class="number">0666</span>(可读，可写)。</span><br><span class="line">callback - 回调函数，带有两个参数如：callback(err, fd)。</span><br><span class="line"></span><br><span class="line">获取文件信息</span><br><span class="line">语法</span><br><span class="line">以下为通过异步模式获取文件信息的语法格式：</span><br><span class="line"><span class="string">``</span><span class="string">`js fs.stat(path, callback)</span></span><br></pre></td></tr></table></figure></p>
<p>参数<br>参数使用说明如下：<br>path - 文件路径。<br>callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。<br>fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件：<br>stats类中的方法有：<br>方法 描述<br>stats.isFile() 如果是文件返回 true，否则返回 false。<br>stats.isDirectory() 如果是目录返回 true，否则返回 false。<br>stats.isBlockDevice() 如果是块设备返回 true，否则返回 false。<br>stats.isCharacterDevice() 如果是字符设备返回 true，否则返回 false。<br>stats.isSymbolicLink() 如果是软链接返回 true，否则返回 false。<br>stats.isFIFO() 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。<br>stats.isSocket() 如果是 Socket 返回 true，否则返回 false。</p>
<p>写入文件<br>语法<br>以下为异步模式下写入文件的语法格式：<br><figure class="highlight js"><figcaption><span>fs.writeFile(filename, data[, options], callback)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果文件存在，该方法写入的内容会覆盖旧的文件内容。</span><br><span class="line">参数</span><br><span class="line">参数使用说明如下：</span><br><span class="line">path - 文件路径。</span><br><span class="line">data - 要写入文件的数据，可以是 <span class="built_in">String</span>(字符串) 或 Buffer(流) 对象。</span><br><span class="line">options - 该参数是一个对象，包含 &#123;encoding, mode, flag&#125;。默认编码为 utf8, 模式为 <span class="number">0666</span> ， flag 为 <span class="string">'w'</span></span><br><span class="line">callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</span><br><span class="line"></span><br><span class="line">读取文件</span><br><span class="line">语法</span><br><span class="line">以下为异步模式下读取文件的语法格式：</span><br><span class="line"><span class="string">``</span><span class="string">`js fs.read(fd, buffer, offset, length, position, callback)</span></span><br></pre></td></tr></table></figure></p>
<p>该方法使用了文件描述符来读取文件。<br>参数<br>参数使用说明如下：<br>fd - 通过 fs.open() 方法返回的文件描述符。<br>buffer - 数据写入的缓冲区。<br>offset - 缓冲区写入的写入偏移量。<br>length - 要从文件中读取的字节数。<br>position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。<br>callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</p>
<p>关闭文件<br>语法<br>以下为异步模式下关闭文件的语法格式：<br><figure class="highlight js"><figcaption><span>fs.close(fd, callback)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">该方法使用了文件描述符来读取文件。</span><br><span class="line">参数</span><br><span class="line">参数使用说明如下：</span><br><span class="line">fd - 通过 fs.open() 方法返回的文件描述符。</span><br><span class="line">callback - 回调函数，没有参数。</span><br><span class="line"></span><br><span class="line">截取文件</span><br><span class="line">语法</span><br><span class="line">以下为异步模式下截取文件的语法格式：</span><br><span class="line"><span class="string">``</span><span class="string">`js fs.ftruncate(fd, len, callback)</span></span><br></pre></td></tr></table></figure></p>
<p>该方法使用了文件描述符来读取文件。<br>参数<br>参数使用说明如下：<br>fd - 通过 fs.open() 方法返回的文件描述符。<br>len - 文件内容截取的长度。<br>callback - 回调函数，没有参数。</p>
<p>先打开，后截取，再读取，最后关闭</p>
<p>删除文件<br>语法<br>以下为删除文件的语法格式：<br><figure class="highlight js"><figcaption><span>fs.unlink(path, callback)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">参数使用说明如下：</span><br><span class="line">path - 文件路径。</span><br><span class="line">callback - 回调函数，没有参数。</span><br><span class="line"></span><br><span class="line">创建目录</span><br><span class="line">语法</span><br><span class="line">以下为创建目录的语法格式：</span><br><span class="line"><span class="string">``</span><span class="string">`js fs.mkdir(path[, mode], callback)</span></span><br></pre></td></tr></table></figure></p>
<p>参数<br>参数使用说明如下：<br>path - 文件路径。<br>mode - 设置目录权限，默认为 0777。<br>callback - 回调函数，没有参数。</p>
<p>读取目录<br>语法<br>以下为读取目录的语法格式：<br><figure class="highlight js"><figcaption><span>fs.readdir(path, callback)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">参数使用说明如下：</span><br><span class="line">path - 文件路径。</span><br><span class="line">callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</span><br><span class="line"></span><br><span class="line">只能读取下边一层目录</span><br><span class="line"></span><br><span class="line">删除目录</span><br><span class="line">语法</span><br><span class="line">以下为删除目录的语法格式：</span><br><span class="line"><span class="string">``</span><span class="string">`js fs.rmdir(path, callback)</span></span><br></pre></td></tr></table></figure></p>
<p>参数<br>参数使用说明如下：<br>path - 文件路径。<br>callback - 回调函数，没有参数。</p>
<p>注意：必须为空文件夹在能删除！！！</p>
<p>fs的实例代码：<br><figure class="highlight js"><figcaption><span>var fs = require('fs');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//异步读取</span></span><br><span class="line">fs.readFile(<span class="string">'input.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"异步读取："</span>+data.toString());</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步读取</span></span><br><span class="line"><span class="keyword">var</span> data=fs.readFileSync(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"同步读取："</span>+data.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步打开文件</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'准备打开文件'</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>,<span class="string">'r+'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err); <span class="comment">//没有return也可以,也可以写成err.stack</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'打开文件成功'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件信息</span></span><br><span class="line">fs.stat(<span class="string">'input.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,stats</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(stats);</span><br><span class="line"><span class="built_in">console</span>.log(stats.isFile()); <span class="comment">//true 判断是不是文件</span></span><br><span class="line"><span class="built_in">console</span>.log(stats.isDirectory()) <span class="comment">//false 判断是否为目录</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备写入文件"</span>);</span><br><span class="line">fs.writeFile(<span class="string">'input.txt'</span>,<span class="string">'这是写入的内容'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="comment">//写入数据会覆盖掉原数据</span></span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'数据写入成功'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'读取写入数据'</span>);</span><br><span class="line">fs.readFile(<span class="string">'input.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'读取数据：'</span>+data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'读取文件开始'</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>,<span class="string">'r+'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'打开文件成功'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'准备读取文件'</span>);</span><br><span class="line">fs.read(fd,buf,<span class="number">0</span>,buf.length,<span class="number">0</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytes</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bytes+<span class="string">'字节被读取'</span>);</span><br><span class="line"><span class="keyword">if</span>(bytes&amp;gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>,bytes).toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件（接着上边那个写）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'读取文件开始'</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>,<span class="string">'r+'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'打开文件成功'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'准备读取文件'</span>);</span><br><span class="line">fs.read(fd,buf,<span class="number">0</span>,buf.length,<span class="number">0</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytes</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bytes+<span class="string">'字节被读取'</span>);</span><br><span class="line"><span class="keyword">if</span>(bytes&amp;gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>,bytes).toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.close(fd,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件关闭成功"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取文件 先打开，后截取，再读取，最后关闭</span></span><br><span class="line">fs.open(<span class="string">'input.txt'</span>,<span class="string">'r+'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'打开文件成功'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'准备读取文件'</span>);</span><br><span class="line">fs.ftruncate(fd,<span class="number">10</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"截取成功"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'再读取相同文件'</span>);</span><br><span class="line">fs.read(fd,buf,<span class="number">0</span>,buf.length,<span class="number">0</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytes</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bytes&amp;gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>,bytes).toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fs.close(fd,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件已经关闭"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log("准备删除文件");</span></span><br><span class="line"><span class="comment">//fs.unlink('in.txt',function(err)&#123;</span></span><br><span class="line"><span class="comment">// if(err)&#123;</span></span><br><span class="line"><span class="comment">// console.log(err);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log('删除成功');</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建目录</span></span><br><span class="line"><span class="comment">//console.log("test");</span></span><br><span class="line"><span class="comment">//fs.mkdir('test1',function(err)&#123; //不知道为什么在这个文件里只能创建一级目录，单放到一个文件内就可以创建二级的</span></span><br><span class="line"><span class="comment">// if (err) &#123;</span></span><br><span class="line"><span class="comment">// return console.error(err);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log("目录创建成功。");</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取目录</span></span><br><span class="line"><span class="comment">//console.log("查看 /test 目录");</span></span><br><span class="line"><span class="comment">//fs.readdir("test1",function(err, files)&#123; //只能读取下边一层目录，也可以读取这一层的文件名</span></span><br><span class="line"><span class="comment">// if (err) &#123;</span></span><br><span class="line"><span class="comment">// return console.error(err);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// files.forEach( function (file)&#123;</span></span><br><span class="line"><span class="comment">// console.log( file );</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除目录</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除目录"</span>);</span><br><span class="line">fs.rmdir(<span class="string">"./test1/1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="comment">//可以指定删除第二层目录的,但是必须为空文件夹</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"读取test 目录"</span>);</span><br><span class="line">fs.readdir(<span class="string">"./test1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line">files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( file );</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Node.js GET/POST请求<br>在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。<br>表单提交到服务器一般都使用GET/POST请求。<br>本章节我们将为大家介绍 Node.js GET/POST请求。</p>
<p>获取GET请求内容<br>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。<br>node.js中url模块中的parse函数提供了这个功能。<br><figure class="highlight js"><figcaption><span>var http = require('http');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>)));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p>在浏览器中访问<a href="http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc" target="_blank" rel="external">http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc</a> 然后查看返回结果:</p>
<p><img class="alignnone size-full wp-image-8041" src="http://www.runoob.com/wp-content/uploads/2014/06/w3cnodejs.jpg" alt="w3cnodejs" width="462" height="265"></p>
<p>获取POST请求内容<br>POST请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。<br>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js默认是不会解析请求体的， 当你需要的时候，需要手动来做。<br><figure class="highlight js"><figcaption><span>var http = require('http');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> post = <span class="string">''</span>; <span class="comment">//定义了一个post变量，用于暂存请求体的信息</span></span><br><span class="line"></span><br><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123; <span class="comment">//通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span></span><br><span class="line">post += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">post = querystring.parse(post);</span><br><span class="line">res.end(util.inspect(post));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p>Node.js Web 模块<br>什么是 Web 服务器？<br>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合。<br>大多数 web 服务器都支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。<br>目前最主流的三个Web服务器是Apache、Nginx、IIS。</p>
<p>Web 应用架构</p>
<p><img title="Web 应用架构" src="http://www.runoob.com/wp-content/uploads/2015/09/web_architecture.jpg" alt=""></p>
<p>Client - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。<br>Server - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。<br>Business - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。<br>Data - 数据层，一般由数据库组成。</p>
<p>使用 Node 创建 Web 服务器<br>Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：</p>
<figure class="highlight js"><figcaption><span>var http = require('http');```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">以下是演示一个最基本的 HTTP 服务器架构(使用<span class="number">8081</span>端口)，创建 server.js 文件，代码如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js var http = require('http');</span><br><span class="line">var fs = require('fs');</span><br><span class="line">var url = require('url');</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建服务器</span><br><span class="line">http.createServer( function (request, response) &#123;  </span><br><span class="line">   // 解析请求，包括文件名</span><br><span class="line">   var pathname = url.parse(request.url).pathname;</span><br><span class="line">   </span><br><span class="line">   // 输出请求的文件名</span><br><span class="line">   console.log("Request for " + pathname + " received.");</span><br><span class="line">   </span><br><span class="line">   // 从文件系统中读取请求的文件内容</span><br><span class="line">   fs.readFile(pathname.substr(1), function (err, data) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">         // HTTP 状态码: 404 : NOT FOUND</span><br><span class="line">         // Content Type: text/plain</span><br><span class="line">         response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;);</span><br><span class="line">      &#125;else&#123;	         </span><br><span class="line">         // HTTP 状态码: 200 : OK</span><br><span class="line">         // Content Type: text/plain</span><br><span class="line">         response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;);	</span><br><span class="line">         </span><br><span class="line">         // 响应文件内容</span><br><span class="line">         response.write(data.toString());		</span><br><span class="line">      &#125;</span><br><span class="line">      //  发送响应数据</span><br><span class="line">      response.end();</span><br><span class="line">   &#125;);   </span><br><span class="line">&#125;).listen(8081);</span><br><span class="line"></span><br><span class="line">// 控制台会输出以下信息</span><br><span class="line">console.log('Server running at http://127.0.0.1:8081/');</span></span><br></pre></td></tr></table></figure>
<p>使用 Node 创建 Web 客户端<br>Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示：</p>
<figure class="highlight js"><figcaption><span>var http = require('http');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 用于请求的选项</span></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   host: <span class="string">'localhost'</span>,</span><br><span class="line">   port: <span class="string">'8081'</span>,</span><br><span class="line">   path: <span class="string">'/index.htm'</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理响应的回调函数</span></span><br><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 不断更新数据</span></span><br><span class="line">   <span class="keyword">var</span> body = <span class="string">''</span>;</span><br><span class="line">   response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      body += data;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   response.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 数据接收完成</span></span><br><span class="line">      <span class="built_in">console</span>.log(body);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向服务端发送请求</span></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, callback);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<p>新开一个终端，执行 client.js 文件，输出结果如下：</p>
<figure class="highlight js"><figcaption><span>$ node client.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello World!</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行 server.js 的控制台输出信息如下：</p>
<figure class="highlight"><figcaption><span>Server running at</span><a href="http://127.0.0.1:8081/" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request for /index.htm received.   # 客户端请求信息</span><br></pre></td></tr></table></figure>
<p><strong>Node.js 工具模块</strong><br>Node.js OS 模块<br>Node.js os 模块提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：<br>var os = require(“os”)</p>
<figure class="highlight js"><figcaption><span>var os = require("os");</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// CPU 的字节序</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'endianness : '</span> + os.endianness());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'type : '</span> + os.type());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'platform : '</span> + os.platform());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统内存总量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'total memory : '</span> + os.totalmem() + <span class="string">" bytes."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统空闲内存量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'free memory : '</span> + os.freemem() + <span class="string">" bytes."</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>endianness : LE</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type : Linux</span><br><span class="line">platform : linux</span><br><span class="line">total memory : <span class="number">25103400960</span> bytes.</span><br><span class="line">free memory : <span class="number">20676710400</span> bytes.</span><br></pre></td></tr></table></figure>
<p>Node.js Path 模块<br>Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块：</p>
<figure class="highlight js"><figcaption><span>var path = require("path")```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js var path = require("path");</span><br><span class="line"></span><br><span class="line">// 格式化路径</span><br><span class="line">console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));</span><br><span class="line"></span><br><span class="line">// 连接路径</span><br><span class="line">console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));</span><br><span class="line"></span><br><span class="line">// 转换为绝对路径</span><br><span class="line">console.log('resolve : ' + path.resolve('main.js'));</span><br><span class="line"></span><br><span class="line">// 路径中文件的后缀名</span><br><span class="line">console.log('ext name : ' + path.extname('main.js'));</span></span><br></pre></td></tr></table></figure>
<p>$ node main.js </p>
<figure class="highlight js"><figcaption><span>normalization :</span><a href="/test/test1/2slashes/1slash">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">joint path : <span class="regexp">/test/</span>test1/<span class="number">2</span>slashes/<span class="number">1</span>slash</span><br><span class="line">resolve : <span class="regexp">/web/</span>com/<span class="number">1427176256</span>_27423/main.js</span><br><span class="line">ext name : .js</span><br></pre></td></tr></table></figure>
<p>Node.js Net 模块<br>Net和Http模块的区别，可以查看下边网址了解<br>odeJS 的数据通信，最基础的两个模块是 Net 和 Http，前者是基于 Tcp 的封装，后者本质还是 Tcp 层，只不过做了比较多的数据封装，我们视为表现层。<br><a href="http://www.jb51.net/article/59801.htm" target="_blank" rel="external">http://www.jb51.net/article/59801.htm</a></p>
<p>Node.js DNS 模块<br>Node.js DNS 模块用于解析域名。引入 DNS 模块语法格式如下：</p>
<figure class="highlight js"><figcaption><span>var dns = require("dns")```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js var dns = require('dns');</span><br><span class="line"></span><br><span class="line">dns.lookup('www.github.com', function onLookup(err, address, family) &#123;</span><br><span class="line">   console.log('ip 地址:', address);</span><br><span class="line">   dns.reverse(address, function (err, hostnames) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">      console.log(err.stack);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   console.log('反向解析 ' + address + ': ' + JSON.stringify(hostnames));</span><br><span class="line">&#125;);  </span><br><span class="line">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>执行以上代码，结果如下所示:</p>
<figure class="highlight js"><figcaption><span>address: 192.30.252.130</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse <span class="keyword">for</span> <span class="number">192.30</span><span class="number">.252</span><span class="number">.130</span>: [<span class="string">"github.com"</span>]</span><br></pre></td></tr></table></figure>
<p>Node.js Domain 模块<br>Node.js Domain(域) 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。引入 Domain 模块 语法格式如下：</p>
<figure class="highlight js"><figcaption><span>var domain = require("domain")```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即推出，与process.on(<span class="string">'uncaughtException'</span>)不同。</span><br><span class="line">Domain 模块可分为隐式绑定和显式绑定：</span><br><span class="line">隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象</span><br><span class="line">显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js var EventEmitter = require("events").EventEmitter;</span><br><span class="line">var domain = require("domain");</span><br><span class="line"></span><br><span class="line">var emitter1 = new EventEmitter();</span><br><span class="line"></span><br><span class="line">// 创建域</span><br><span class="line">var domain1 = domain.create();</span><br><span class="line"></span><br><span class="line">domain1.on('error', function(err)&#123;</span><br><span class="line">   console.log("domain1 处理这个错误 ("+err.message+")");</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 显式绑定</span><br><span class="line">domain1.add(emitter1);</span><br><span class="line"></span><br><span class="line">emitter1.on('error',function(err)&#123;</span><br><span class="line">   console.log("监听器处理此错误 ("+err.message+")");</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter1.emit('error',new Error('通过监听器来处理'));</span><br><span class="line"></span><br><span class="line">emitter1.removeAllListeners('error');</span><br><span class="line"></span><br><span class="line">emitter1.emit('error',new Error('通过 domain1 处理'));</span><br><span class="line"></span><br><span class="line">var domain2 = domain.create();</span><br><span class="line"></span><br><span class="line">domain2.on('error', function(err)&#123;</span><br><span class="line">   console.log("domain2 处理这个错误 ("+err.message+")");</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 隐式绑定</span><br><span class="line">domain2.run(function()&#123;</span><br><span class="line">   var emitter2 = new EventEmitter();</span><br><span class="line">   emitter2.emit('error',new Error('通过 domain2 处理'));   </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">domain1.remove(emitter1);</span><br><span class="line">emitter1.emit('error', new Error('转换为异常，系统将崩溃!'));</span></span><br></pre></td></tr></table></figure>
<p>执行以上代码，结果如下所示:</p>
<figure class="highlight js"><figcaption><span>监听器处理此错误 (通过监听器来处理)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">domain1 处理这个错误 (通过 domain1 处理)</span><br><span class="line">domain2 处理这个错误 (通过 domain2 处理)</span><br><span class="line"></span><br><span class="line">events.js:<span class="number">72</span></span><br><span class="line">        <span class="keyword">throw</span> er; <span class="comment">// Unhandled 'error' event</span></span><br><span class="line">              ^</span><br><span class="line"><span class="built_in">Error</span>: 转换为异常，系统将崩溃!</span><br><span class="line">    at <span class="built_in">Object</span>.&lt;anonymous&gt; (<span class="regexp">/www/</span>node/main.js:<span class="number">40</span>:<span class="number">24</span>)</span><br><span class="line">    at Module._compile (<span class="built_in">module</span>.js:<span class="number">456</span>:<span class="number">26</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.Module._extensions..js (<span class="built_in">module</span>.js:<span class="number">474</span>:<span class="number">10</span>)</span><br><span class="line">    at Module.load (<span class="built_in">module</span>.js:<span class="number">356</span>:<span class="number">32</span>)</span><br><span class="line">    at <span class="built_in">Function</span>.Module._load (<span class="built_in">module</span>.js:<span class="number">312</span>:<span class="number">12</span>)</span><br><span class="line">    at <span class="built_in">Function</span>.Module.runMain (<span class="built_in">module</span>.js:<span class="number">497</span>:<span class="number">10</span>)</span><br><span class="line">    at startup (node.js:<span class="number">119</span>:<span class="number">16</span>)</span><br><span class="line">    at node.js:<span class="number">929</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>Node.js RESTful API</strong><br>什么是 REST？<br>RREST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。<br>表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。<br>HTTP 方法<br>以下为 REST 基本架构的四个方法：<br>GET - 用于获取数据。<br>PUT - 用于添加数据。<br>DELETE - 用于删除数据。<br>POST - 用于更新或添加数据。</p>
<p>HTTP 方法<br>以下为 REST 基本架构的四个方法：<br>GET - 用于获取数据。<br>PUT - 用于添加数据。<br>DELETE - 用于删除数据。<br>POST - 用于更新或添加数据。</p>
<p>获取用户列表<br>var express = require(‘express’);<br>var app = express();<br>var fs = require(“fs”);</p>
<figure class="highlight js"><figcaption><span>app.get('/listUsers', function (req, res) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( data );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来执行以下命令：<br>$ node server.js<br>应用实例，访问地址为 <a href="http://0.0.0.0:8081" target="_blank" rel="external">http://0.0.0.0:8081</a><br>在浏览器中访问 <a href="http://127.0.0.1:8081/listUsers，显示结果" target="_blank" rel="external">http://127.0.0.1:8081/listUsers，显示结果</a></p>
<p>添加用户</p>
<figure class="highlight js"><figcaption><span>var express = require('express');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加的新用户数据</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">   <span class="string">"user4"</span> : &#123;</span><br><span class="line">      <span class="string">"name"</span> : <span class="string">"mohit"</span>,</span><br><span class="line">      <span class="string">"password"</span> : <span class="string">"password4"</span>,</span><br><span class="line">      <span class="string">"profession"</span> : <span class="string">"teacher"</span>,</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/addUser'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 读取已存在的数据</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       data[<span class="string">"user4"</span>] = user[<span class="string">"user4"</span>];</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行方法是一样的。</p>
<p>显示用户详情</p>
<figure class="highlight js"><figcaption><span>var express = require('express');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 首先我们读取已存在的用户</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">var</span> user = data[<span class="string">"user"</span> + req.params.id] </span><br><span class="line">       <span class="built_in">console</span>.log( user );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>删除用户</p>
<figure class="highlight js"><figcaption><span>var express = require('express');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/deleteUser'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First read existing users.</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">delete</span> data[<span class="string">"user"</span> + <span class="number">2</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>Node.js 多进程```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</span><br><span class="line">每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr（分别是标准输出，标准输入和标准错误。）。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</span><br><span class="line">Node 提供了 child_process 模块来创建子进程，方法有：</span><br><span class="line">exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</span><br><span class="line">spawn - child_process.spawn 使用指定的命令行参数创建新线程。</span><br><span class="line">fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(<span class="string">'./son.js'</span>) 相当于 spawn(<span class="string">'node'</span>, [<span class="string">'./son.js'</span>]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</span><br><span class="line"></span><br><span class="line">exec() 方法</span><br><span class="line">child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</span><br><span class="line">语法如下所示：</span><br><span class="line">child_process.exec(command[, options], callback)</span><br><span class="line">参数</span><br><span class="line">参数说明如下：</span><br><span class="line">command： 字符串， 将要运行的命令，参数使用空格隔开</span><br><span class="line">options ：对象，可以是：</span><br><span class="line">cwd ，字符串，子进程的当前工作目录</span><br><span class="line">env，对象 环境变量键值对</span><br><span class="line">encoding ，字符串，字符编码（默认： <span class="string">'utf8'</span>）</span><br><span class="line">shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为/bin/sh， 在 Windows 中为cmd.exe， Shell 应当能识别 -c开关在 UNIX 中，或 /s /c 在 Windows 中。 在Windows 中，命令行解析应当能兼容cmd.exe）</span><br><span class="line">timeout，数字，超时时间（默认： <span class="number">0</span>）</span><br><span class="line">maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认: <span class="number">200</span>*<span class="number">1024</span>）</span><br><span class="line">killSignal ，字符串，结束信号（默认：<span class="string">'SIGTERM'</span>）</span><br><span class="line">uid，数字，设置用户进程的 ID</span><br><span class="line">gid，数字，设置进程组的 ID</span><br><span class="line">callback ：回调函数，包含三个参数error, stdout 和 stderr。</span><br><span class="line">exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">让我们创建两个 js 文件 support.js 和 master.js。</span><br><span class="line">support.js 文件代码：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js console.log("进程 " + process.argv[2] + " 执行。" );</span></span><br></pre></td></tr></table></figure>
<p>master.js 文件代码：</p>
<figure class="highlight js"><figcaption><span>const fs = require('fs');</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> workerProcess = child_process.exec(<span class="string">'node support.js '</span>+i,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error.stack);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error code: '</span>+error.code);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Signal received: '</span>+error.signal);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + stdout);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + stderr);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      workerProcess.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span>+code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：<br>$ node master.js </p>
<figure class="highlight js"><figcaption><span>子进程已退出，退出码 0</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stdout: 进程 <span class="number">0</span> 执行。</span><br><span class="line"></span><br><span class="line">stderr: </span><br><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br><span class="line">stdout: 进程 <span class="number">1</span> 执行。</span><br><span class="line"></span><br><span class="line">stderr: </span><br><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br><span class="line">stdout: 进程 <span class="number">2</span> 执行。</span><br><span class="line"></span><br><span class="line">stderr:</span><br></pre></td></tr></table></figure>
<p>spawn() 方法<br>child_process.spawn 使用指定的命令行参数创建新线程，语法格式如下：<br>child_process.spawn(command[, args][, options])<br>参数<br>参数说明如下：<br>command： 将要运行的命令<br>args： Array 字符串参数数组<br>options Object<br>cwd String 子进程的当前工作目录<br>env Object 环境变量键值对<br>stdio Array|String 子进程的 stdio 配置<br>detached Boolean 这个子进程将会变成进程组的领导<br>uid Number 设置用户进程的 ID<br>gid Number 设置进程组的 ID<br>spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。<br>实例<br>让我们创建两个 js 文件 support.js 和 master.js。<br>support.js 文件代码：</p>
<figure class="highlight js"><figcaption><span>console.log("进程 " + process.argv[2] + " 执行。" );```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">master.js 文件代码：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js const fs = require('fs');</span><br><span class="line">const child_process = require('child_process');</span><br><span class="line"> </span><br><span class="line">for(var i=0; i&lt;3; i++) &#123;</span><br><span class="line">   var workerProcess = child_process.spawn('node', ['support.js', i]);</span><br><span class="line"></span><br><span class="line">   workerProcess.stdout.on('data', function (data) &#123;</span><br><span class="line">      console.log('stdout: ' + data);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   workerProcess.stderr.on('data', function (data) &#123;</span><br><span class="line">      console.log('stderr: ' + data);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   workerProcess.on('close', function (code) &#123;</span><br><span class="line">      console.log('子进程已退出，退出码 '+code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：<br>$ node master.js </p>
<figure class="highlight js"><figcaption><span>stdout: 进程 0 执行。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br><span class="line">stdout: 进程 <span class="number">1</span> 执行。</span><br><span class="line"></span><br><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br><span class="line">stdout: 进程 <span class="number">2</span> 执行。</span><br><span class="line"></span><br><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>fork 方法<br>child_process.fork 是 spawn() 方法的特殊形式，用于创建进程，语法格式如下：</p>
<figure class="highlight js"><figcaption><span>child_process.fork(modulePath[, args][, options])```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">参数说明如下：</span><br><span class="line">modulePath： <span class="built_in">String</span>，将要在子进程中运行的模块</span><br><span class="line">args： <span class="built_in">Array</span> 字符串参数数组</span><br><span class="line">options：<span class="built_in">Object</span></span><br><span class="line">cwd <span class="built_in">String</span> 子进程的当前工作目录</span><br><span class="line">env <span class="built_in">Object</span> 环境变量键值对</span><br><span class="line">execPath <span class="built_in">String</span> 创建子进程的可执行文件</span><br><span class="line">execArgv <span class="built_in">Array</span> 子进程的可执行文件的字符串参数数组（默认： process.execArgv）</span><br><span class="line">silent <span class="built_in">Boolean</span> 如果为<span class="literal">true</span>，子进程的stdin，stdout和stderr将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：<span class="literal">false</span>）</span><br><span class="line">uid <span class="built_in">Number</span> 设置用户进程的 ID</span><br><span class="line">gid <span class="built_in">Number</span> 设置进程组的 ID</span><br><span class="line">返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。</span><br><span class="line">实例</span><br><span class="line"></span><br><span class="line">support.js 文件代码：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js console.log("进程 " + process.argv[2] + " 执行。" );</span><br><span class="line">master.js 文件代码：</span><br><span class="line">const fs = require('fs');</span><br><span class="line">const child_process = require('child_process');</span><br><span class="line"> </span><br><span class="line">for(var i=0; i&lt;3; i++) &#123;</span><br><span class="line">   var worker_process = child_process.fork("support.js", [i]);	</span><br><span class="line"></span><br><span class="line">   worker_process.on('close', function (code) &#123;</span><br><span class="line">      console.log('子进程已退出，退出码 ' + code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：<br>$ node master.js </p>
<figure class="highlight js"><figcaption><span>进程 0 执行。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br><span class="line">进程 <span class="number">1</span> 执行。</span><br><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br><span class="line">进程 <span class="number">2</span> 执行。</span><br><span class="line">子进程已退出，退出码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>js Node.js JXcore 打包</code></p>
<p>Node.js 是一个开放源代码、跨平台的、用于服务器端和网络应用的运行环境。<br>JXcore 是一个支持多线程的 Node.js 发行版本，基本不需要对你现有的代码做任何改动就可以直接线程安全地以多线程运行。<br>但我们这篇文章主要是要教大家介绍 JXcore 的打包功能。</p>

					</div>


					<div class="content-tag">

<a class="tag-link" href="/tags/nodejs/">nodejs</a>, <a class="tag-link" href="/tags/note/">note</a>, <a class="tag-link" href="/tags/笔记/">笔记</a>

					</div>



				</article>
			</div>

		</div>

		<div class="panel-post-nav">
			<div class="box-post-nav">


					<a href="/2016/04/07/MongoDB--学习笔记/" title="MongoDB--学习笔记">&larr; Prev</a>



					<a href="/2016/04/07/Webpack--学习笔记/" title="Webpack--学习笔记">Next &rarr;</a>


			</div>
		</div>
		<div class="content-comments">
		
  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/04/07/Nodejs--学习笔记/index.html" data-title="Nodejs--学习笔记" data-url="/2016/04/07/Nodejs--学习笔记/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'pengweb'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  
		</div>
		

	</div>

	<div class="layout-footer" style="clear: both">
		<div class="panel-footer">
			<div class="box-footer">
				<footer class="footer">
					<p class="cr">&copy; 2016 <a href="https://github.com/pengweb"  target="_blank" target="_blank">Pengzhang</a> 
					<span class="theme">Powered: <a href="https://github.com/pengweb/pengweb.github.io" target="_blank">pengweb.net</a>, 京ICP备: <a href="" target="_blank">15017479</a></span>
					</p>

					
				</footer>
			</div>
		</div>
	</div>




</body>
</html>
